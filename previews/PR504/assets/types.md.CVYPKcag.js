import{_ as o,C as p,c as r,o as h,j as i,aA as n,a as e,G as t,w as l}from"./chunks/framework.mhS8UYET.js";const L=JSON.parse('{"title":"Types","description":"","frontmatter":{},"headers":[],"relativePath":"types.md","filePath":"types.md","lastUpdated":null}'),d={name:"types.md"},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""};function S(P,s,M,B,N,R){const a=p("Badge");return h(),r("div",null,[s[78]||(s[78]=i("h1",{id:"Types",tabindex:"-1"},[e("Types "),i("a",{class:"header-anchor",href:"#Types","aria-label":'Permalink to "Types {#Types}"'},"​")],-1)),s[79]||(s[79]=i("h2",{id:"Equations",tabindex:"-1"},[e("Equations "),i("a",{class:"header-anchor",href:"#Equations","aria-label":'Permalink to "Equations {#Equations}"'},"​")],-1)),s[80]||(s[80]=i("p",null,[e("Equations are specified as binary trees with the "),i("code",null,"Node"),e(" type, defined as follows.")],-1)),i("details",k,[i("summary",null,[s[0]||(s[0]=i("a",{id:"DynamicExpressions.NodeModule.Node",href:"#DynamicExpressions.NodeModule.Node"},[i("span",{class:"jlbinding"},"DynamicExpressions.NodeModule.Node")],-1)),s[1]||(s[1]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[3]||(s[3]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Node{T,D} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpressionNode{T,D}</span></span></code></pre></div><p>Node defines a symbolic expression stored in a binary tree. A single <code>Node</code> instance is one &quot;node&quot; of this tree, and has references to its children. By tracing through the children nodes, you can evaluate or print a given expression.</p><p><strong>Fields</strong></p><ul><li><p><code>degree::UInt8</code>: Degree of the node. 0 for constants, 1 for unary operators, 2 for binary operators, etc. Maximum of <code>D</code>.</p></li><li><p><code>constant::Bool</code>: Whether the node is a constant.</p></li><li><p><code>val::T</code>: Value of the node. If <code>degree==0</code>, and <code>constant==true</code>, this is the value of the constant. It has a type specified by the overall type of the <code>Node</code> (e.g., <code>Float64</code>).</p></li><li><p><code>feature::UInt16</code>: Index of the feature to use in the case of a feature node. Only defined if <code>degree == 0 &amp;&amp; constant == false</code>.</p></li><li><p><code>op::UInt8</code>: If <code>degree==1</code>, this is the index of the operator in <code>operators.unaops</code>. If <code>degree==2</code>, this is the index of the operator in <code>operators.binops</code>. In other words, this is an enum of the operators, and is dependent on the specific <code>OperatorEnum</code> object. Only defined if <code>degree &gt;= 1</code></p></li><li><p><code>children::NTuple{D,Node{T,D}}</code>: Children of the node. Only defined up to <code>degree</code></p></li></ul><p>For accessing and modifying children, use <a href="./@ref"><code>get_child</code></a>, <a href="./@ref"><code>set_child!</code></a>, <a href="./@ref"><code>get_children</code></a>, and <a href="./@ref"><code>set_children!</code></a>.</p><p><strong>Constructors</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Node([T]; val=nothing, feature=nothing, op=nothing, children=nothing, allocator=default_allocator)</span></span>
<span class="line"><span>Node{T}(; val=nothing, feature=nothing, op=nothing, children=nothing, allocator=default_allocator)</span></span></code></pre></div><p>Create a new node in an expression tree. If <code>T</code> is not specified in either the type or the first argument, it will be inferred from the value of <code>val</code> passed or the children. The <code>children</code> keyword is used to pass in a collection of children nodes.</p><p>You may also construct nodes via the convenience operators generated by creating an <code>OperatorEnum</code>.</p><p>You may also choose to specify a default memory allocator for the node other than simply <code>Node{T}()</code> in the <code>allocator</code> keyword argument.</p>`,10)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[2]||(s[2]=[i("a",{href:"https://github.com/SymbolicML/DynamicExpressions.jl/blob/v2.4.0/src/Node.jl#L92-L134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[81]||(s[81]=n('<p>When you create an <a href="/SymbolicRegression.jl/dev/api#Options"><code>Options</code></a> object, the operators passed are also re-defined for <code>Node</code> types. This allows you use, e.g., <code>t=Node(; feature=1) * 3f0</code> to create a tree, so long as <code>*</code> was specified as a binary operator. This works automatically for operators defined in <code>Base</code>, although you can also get this to work for user-defined operators by using <code>@extend_operators</code>:</p>',1)),i("details",c,[i("summary",null,[s[4]||(s[4]=i("a",{id:"SymbolicRegression.InterfaceDynamicExpressionsModule.@extend_operators-Tuple{Any}",href:"#SymbolicRegression.InterfaceDynamicExpressionsModule.@extend_operators-Tuple{Any}"},[i("span",{class:"jlbinding"},"SymbolicRegression.InterfaceDynamicExpressionsModule.@extend_operators")],-1)),s[5]||(s[5]=e()),t(a,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),s[7]||(s[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@extend_operators</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options</span></span></code></pre></div><p>Extends all operators defined in this options object to work on the <code>AbstractExpressionNode</code> type. While by default this is already done for operators defined in <code>Base</code> when you create an options and pass <code>define_helper_functions=true</code>, this does not apply to the user-defined operators. Thus, to do so, you must apply this macro to the operator enum in the same module you have the operators defined.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[6]||(s[6]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/InterfaceDynamicExpressions.jl#L319-L328",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[82]||(s[82]=n('<p>When using these node constructors, types will automatically be promoted. You can convert the type of a node using <code>convert</code>:</p><div class="warning custom-block"><p class="custom-block-title">Missing docstring.</p><p>Missing docstring for <code>convert(::Type{Node{T1}}, tree::Node{T2}) where {T1, T2}</code>. Check Documenter&#39;s build log for details.</p></div><p>You can set a <code>tree</code> (in-place) with <code>set_node!</code>:</p>',3)),i("details",E,[i("summary",null,[s[8]||(s[8]=i("a",{id:"DynamicExpressions.NodeModule.set_node!",href:"#DynamicExpressions.NodeModule.set_node!"},[i("span",{class:"jlbinding"},"DynamicExpressions.NodeModule.set_node!")],-1)),s[9]||(s[9]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[11]||(s[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_node!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpressionNode{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, new_tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpressionNode{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Set every field of <code>tree</code> equal to the corresponding field of <code>new_tree</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[10]||(s[10]=[i("a",{href:"https://github.com/SymbolicML/DynamicExpressions.jl/blob/v2.4.0/src/Node.jl#L467-L471",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[83]||(s[83]=i("p",null,[e("You can create a copy of a node with "),i("code",null,"copy_node"),e(":")],-1)),i("details",g,[i("summary",null,[s[12]||(s[12]=i("a",{id:"DynamicExpressions.NodeModule.copy_node-Tuple{Node}",href:"#DynamicExpressions.NodeModule.copy_node-Tuple{Node}"},[i("span",{class:"jlbinding"},"DynamicExpressions.NodeModule.copy_node")],-1)),s[13]||(s[13]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[15]||(s[15]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">copy_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpressionNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; break_sharing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{BS}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {BS}</span></span></code></pre></div><p>Copy a node, recursively copying all children nodes. This is more efficient than the built-in copy.</p><p>If <code>break_sharing</code> is set to <code>Val(true)</code>, sharing in a tree will be ignored.</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[14]||(s[14]=[i("a",{href:"https://github.com/SymbolicML/DynamicExpressions.jl/blob/v2.4.0/src/base.jl#L488-L495",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[84]||(s[84]=i("h2",{id:"Expressions",tabindex:"-1"},[e("Expressions "),i("a",{class:"header-anchor",href:"#Expressions","aria-label":'Permalink to "Expressions {#Expressions}"'},"​")],-1)),s[85]||(s[85]=i("p",null,[e("Expressions are represented using the "),i("a",{href:"/SymbolicRegression.jl/dev/types#DynamicExpressions.ExpressionModule.Expression"},[i("code",null,"Expression")]),e(" type, which combines the raw "),i("a",{href:"/SymbolicRegression.jl/dev/types#DynamicExpressions.NodeModule.Node"},[i("code",null,"Node")]),e(" type with an "),i("code",null,"OperatorEnum"),e(".")],-1)),i("details",u,[i("summary",null,[s[16]||(s[16]=i("a",{id:"DynamicExpressions.ExpressionModule.Expression",href:"#DynamicExpressions.ExpressionModule.Expression"},[i("span",{class:"jlbinding"},"DynamicExpressions.ExpressionModule.Expression")],-1)),s[17]||(s[17]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[19]||(s[19]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Expression{T, N, D} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpression{T, N}</span></span></code></pre></div><p>(Experimental) Defines a high-level, user-facing, expression type that encapsulates an expression tree (like <code>Node</code>) along with associated metadata for evaluation and rendering.</p><p><strong>Fields</strong></p><ul><li><p><code>tree::N</code>: The root node of the raw expression tree.</p></li><li><p><code>metadata::Metadata{D}</code>: A named tuple of settings for the expression, such as the operators and variable names.</p></li></ul><p><strong>Constructors</strong></p><ul><li><p><code>Expression(tree::AbstractExpressionNode, metadata::NamedTuple)</code>: Construct from the fields</p></li><li><p><code>@parse_expression(expr, operators=operators, variable_names=variable_names, node_type=Node)</code>: Parse a Julia expression with a given context and create an Expression object.</p></li></ul><p><strong>Usage</strong></p><p>This type is intended for end-users to interact with and manipulate expressions at a high level, abstracting away the complexities of the underlying expression tree operations.</p>',8)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[18]||(s[18]=[i("a",{href:"https://github.com/SymbolicML/DynamicExpressions.jl/blob/v2.4.0/src/Expression.jl#L71-L92",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",y,[i("summary",null,[s[20]||(s[20]=i("a",{id:"SymbolicRegression.CoreModule.ExpressionSpecModule.ExpressionSpec",href:"#SymbolicRegression.CoreModule.ExpressionSpecModule.ExpressionSpec"},[i("span",{class:"jlbinding"},"SymbolicRegression.CoreModule.ExpressionSpecModule.ExpressionSpec")],-1)),s[21]||(s[21]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[23]||(s[23]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExpressionSpec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpressionSpec</span></span></code></pre></div><p>(Experimental) Default specification for basic expressions without special options.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[22]||(s[22]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/ExpressionSpec.jl#L7-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[86]||(s[86]=i("p",null,"These types allow you to define and manipulate expressions with a clear separation between the structure and the operators used.",-1)),s[87]||(s[87]=i("h3",{id:"Template-Expressions",tabindex:"-1"},[e("Template Expressions "),i("a",{class:"header-anchor",href:"#Template-Expressions","aria-label":'Permalink to "Template Expressions {#Template-Expressions}"'},"​")],-1)),s[88]||(s[88]=i("p",null,[e("Template expressions allow you to specify predefined structures and constraints for your expressions. These use "),i("code",null,"ComposableExpressions"),e(" as their internal expression type, which makes them flexible for creating a structure out of a single function.")],-1)),s[89]||(s[89]=i("p",null,[e("These use the "),i("code",null,"TemplateStructure"),e(" type to define how expressions should be combined and evaluated.")],-1)),i("details",b,[i("summary",null,[s[24]||(s[24]=i("a",{id:"SymbolicRegression.TemplateExpressionModule.TemplateExpression",href:"#SymbolicRegression.TemplateExpressionModule.TemplateExpression"},[i("span",{class:"jlbinding"},"SymbolicRegression.TemplateExpressionModule.TemplateExpression")],-1)),s[25]||(s[25]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[27]||(s[27]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TemplateExpression{T,F,N,E,TS,D} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpression{T,N}</span></span></code></pre></div><p>A symbolic expression that allows the combination of multiple sub-expressions in a structured way, with constraints on variable usage.</p><p><code>TemplateExpression</code> is designed for symbolic regression tasks where domain-specific knowledge or constraints must be imposed on the model&#39;s structure.</p><p><strong>Constructor</strong></p><ul><li><code>TemplateExpression(trees; structure, operators, variable_names)</code><ul><li><p><code>trees</code>: A <code>NamedTuple</code> holding the sub-expressions (e.g., <code>f = Expression(...)</code>, <code>g = Expression(...)</code>).</p></li><li><p><code>structure</code>: A <code>TemplateStructure</code> which holds functions that define how the sub-expressions are combined in different contexts.</p></li><li><p><code>operators</code>: An <code>OperatorEnum</code> that defines the allowed operators for the sub-expressions.</p></li><li><p><code>variable_names</code>: An optional <code>Vector</code> of <code>String</code> that defines the names of the variables in the dataset.</p></li></ul></li></ul><p><strong>Example</strong></p><p>Let&#39;s create an example <code>TemplateExpression</code> that combines two sub-expressions <code>f(x1, x2)</code> and <code>g(x3)</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define operators and variable names</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; binary_operators</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), unary_operators</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sin, cos))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">operators </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">operators</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">variable_names </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create sub-expressions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Expression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Node{Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; feature</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); operators, variable_names)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Expression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Node{Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; feature</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); operators, variable_names)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Expression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Node{Float64}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; feature</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); operators, variable_names)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create TemplateExpression</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">example_expr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (; f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x1, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">st_expr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TemplateExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    example_expr;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    structure</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TemplateStructure{(:f, :g)}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ((; f, g), (x1, x2, x3)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x1, x2)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x3)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    operators,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    variable_names,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>When fitting a model in SymbolicRegression.jl, you can provide <code>expression_spec=TemplateExpressionSpec(; structure=TemplateStructure(...))</code> as an option. The <code>variable_constraints</code> will constraint <code>f</code> to only have access to <code>x1</code> and <code>x2</code>, and <code>g</code> to only have access to <code>x3</code>.</p>`,9)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[26]||(s[26]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/TemplateExpression.jl#L243-L292",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",m,[i("summary",null,[s[28]||(s[28]=i("a",{id:"SymbolicRegression.TemplateExpressionModule.TemplateStructure",href:"#SymbolicRegression.TemplateExpressionModule.TemplateStructure"},[i("span",{class:"jlbinding"},"SymbolicRegression.TemplateExpressionModule.TemplateStructure")],-1)),s[29]||(s[29]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[31]||(s[31]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TemplateStructure{K,E,NF} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Function</span></span></code></pre></div><p>A struct that defines a prescribed structure for a <code>TemplateExpression</code>, including functions that define the result in different contexts.</p><p>The <code>K</code> parameter is used to specify the symbols representing the inner expressions. If not declared using the constructor <code>TemplateStructure{K}(...)</code>, the keys of the <code>variable_constraints</code> <code>NamedTuple</code> will be used to infer this.</p><p>The <code>Kp</code> parameter is used to specify the symbols representing the parameters, if any.</p><p><strong>Fields</strong></p><ul><li><p><code>combine</code>: Required function taking a <code>NamedTuple</code> of <code>ComposableExpression</code>s (sharing the keys <code>K</code>), and then tuple representing the data of <code>ValidVector</code>s. For example, <code>((; f, g), (x1, x2, x3)) -&gt; f(x1, x2) + g(x3)</code> would be a valid <code>combine</code> function. You may also re-use the callable expressions and use different inputs, such as <code>((; f, g), (x1, x2)) -&gt; f(x1 + g(x2)) - g(x1)</code> is another valid choice.</p></li><li><p><code>num_features</code>: Optional <code>NamedTuple</code> of function keys =&gt; integers representing the number of features used by each expression. If not provided, it will be inferred using the <code>combine</code> function. For example, if <code>f</code> takes two arguments, and <code>g</code> takes one, then <code>num_features = (; f=2, g=1)</code>.</p></li><li><p><code>num_parameters</code>: Optional <code>NamedTuple</code> of parameter keys =&gt; integers representing the number of parameters required for each parameter vector.</p></li></ul>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[30]||(s[30]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/TemplateExpression.jl#L81-L105",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",f,[i("summary",null,[s[32]||(s[32]=i("a",{id:"SymbolicRegression.TemplateExpressionModule.TemplateExpressionSpec",href:"#SymbolicRegression.TemplateExpressionModule.TemplateExpressionSpec"},[i("span",{class:"jlbinding"},"SymbolicRegression.TemplateExpressionModule.TemplateExpressionSpec")],-1)),s[33]||(s[33]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[35]||(s[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TemplateExpressionSpec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpressionSpec</span></span></code></pre></div><p>(Experimental) Specification for template expressions with pre-defined structure.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[34]||(s[34]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/TemplateExpression.jl#L966-L970",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[90]||(s[90]=n('<p>You can use the <code>@template_spec</code> macro as an easy way to create a <code>TemplateExpressionSpec</code>:</p><div class="warning custom-block"><p class="custom-block-title">Missing docstring.</p><p>Missing docstring for <code>@template_spec</code>. Check Documenter&#39;s build log for details.</p></div><p>Composable expressions are used internally by <code>TemplateExpression</code> and allow you to combine multiple expressions together.</p>',3)),i("details",x,[i("summary",null,[s[36]||(s[36]=i("a",{id:"SymbolicRegression.ComposableExpressionModule.ComposableExpression",href:"#SymbolicRegression.ComposableExpressionModule.ComposableExpression"},[i("span",{class:"jlbinding"},"SymbolicRegression.ComposableExpressionModule.ComposableExpression")],-1)),s[37]||(s[37]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[39]||(s[39]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ComposableExpression{T,N,D} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractComposableExpression{T,N}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpression{T,N}</span></span></code></pre></div><p>A symbolic expression representing a mathematical formula as an expression tree (<code>tree::N</code>) with associated metadata (<code>metadata::Metadata{D}</code>). Used to construct and manipulate expressions in symbolic regression tasks.</p><p>Example:</p><p>Create variables <code>x1</code> and <code>x2</code>, and build an expression <code>f = x1 * sin(x2)</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">operators </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OperatorEnum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; binary_operators</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), unary_operators</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sin, cos))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">variable_names </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComposableExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Float64; feature</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); operators, variable_names)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComposableExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Float64; feature</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); operators, variable_names)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x2)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ^This now references the first and second arguments of things passed to it:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x1, x1) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># == x1 * sin(x1)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">randn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">randn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># == randn(5) .* sin.(randn(5))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># You can even pass it to itself:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, f) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># == (x1 * sin(x2)) * sin((x1 * sin(x2)))</span></span></code></pre></div>`,5)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[38]||(s[38]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/ComposableExpression.jl#L28-L51",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[91]||(s[91]=i("h3",{id:"Parametric-Expressions",tabindex:"-1"},[e("Parametric Expressions "),i("a",{class:"header-anchor",href:"#Parametric-Expressions","aria-label":'Permalink to "Parametric Expressions {#Parametric-Expressions}"'},"​")],-1)),s[92]||(s[92]=i("p",null,"Parametric expressions are a type of expression that includes parameters which can be optimized during the search.",-1)),i("details",C,[i("summary",null,[s[40]||(s[40]=i("a",{id:"DynamicExpressions.ParametricExpressionModule.ParametricExpression",href:"#DynamicExpressions.ParametricExpressionModule.ParametricExpression"},[i("span",{class:"jlbinding"},"DynamicExpressions.ParametricExpressionModule.ParametricExpression")],-1)),s[41]||(s[41]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[43]||(s[43]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ParametricExpression{T,N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ParametricNode{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpression{T,N}</span></span></code></pre></div><p>(Experimental) An expression to store parameters for a tree</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[42]||(s[42]=[i("a",{href:"https://github.com/SymbolicML/DynamicExpressions.jl/blob/v2.4.0/src/ParametricExpression.jl#L78-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",T,[i("summary",null,[s[44]||(s[44]=i("a",{id:"DynamicExpressions.ParametricExpressionModule.ParametricNode",href:"#DynamicExpressions.ParametricExpressionModule.ParametricNode"},[i("span",{class:"jlbinding"},"DynamicExpressions.ParametricExpressionModule.ParametricNode")],-1)),s[45]||(s[45]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[47]||(s[47]=i("p",null,"A type of expression node that also stores a parameter index",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[46]||(s[46]=[i("a",{href:"https://github.com/SymbolicML/DynamicExpressions.jl/blob/v2.4.0/src/ParametricExpression.jl#L51",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",F,[i("summary",null,[s[48]||(s[48]=i("a",{id:"SymbolicRegression.ParametricExpressionModule.ParametricExpressionSpec",href:"#SymbolicRegression.ParametricExpressionModule.ParametricExpressionSpec"},[i("span",{class:"jlbinding"},"SymbolicRegression.ParametricExpressionModule.ParametricExpressionSpec")],-1)),s[49]||(s[49]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[51]||(s[51]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ParametricExpressionSpec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractExpressionSpec</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">Warning</p><p><code>ParametricExpressionSpec</code> is no longer recommended. Please use <code>@template_spec</code> (creating a <code>TemplateExpressionSpec</code>) instead.</p></div><p>(Experimental) Specification for parametric expressions with configurable maximum parameters.</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[50]||(s[50]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/ParametricExpression.jl#L196-L203",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[93]||(s[93]=i("p",null,[e("These types allow you to define expressions with parameters that can be tuned to fit the data better. You can specify the maximum number of parameters using the "),i("code",null,"expression_options"),e(" argument in "),i("code",null,"SRRegressor"),e(".")],-1)),s[94]||(s[94]=i("h2",{id:"Population",tabindex:"-1"},[e("Population "),i("a",{class:"header-anchor",href:"#Population","aria-label":'Permalink to "Population {#Population}"'},"​")],-1)),s[95]||(s[95]=i("p",null,[e("Groups of equations are given as a population, which is an array of trees tagged with cost, loss, and birthdate–-these values are given in the "),i("code",null,"PopMember"),e(".")],-1)),i("details",_,[i("summary",null,[s[52]||(s[52]=i("a",{id:"SymbolicRegression.PopulationModule.Population",href:"#SymbolicRegression.PopulationModule.Population"},[i("span",{class:"jlbinding"},"SymbolicRegression.PopulationModule.Population")],-1)),s[53]||(s[53]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[57]||(s[57]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Population</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Array{PopMember{T,L}, 1}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create population from list of PopMembers.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[54]||(s[54]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/Population.jl#L19-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),s[58]||(s[58]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Population</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dataset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dataset{T,L}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           population_size, nlength</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           nfeatures</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create random population and evaluate them on the dataset.</p>`,2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[55]||(s[55]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/Population.jl#L28-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),s[59]||(s[59]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Population</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           population_size, nlength</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nfeatures</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           loss_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Nothing)</span></span></code></pre></div><p>Create random population and score them on the dataset.</p>`,2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[56]||(s[56]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/Population.jl#L62-L69",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[96]||(s[96]=i("h2",{id:"Population-members",tabindex:"-1"},[e("Population members "),i("a",{class:"header-anchor",href:"#Population-members","aria-label":'Permalink to "Population members {#Population-members}"'},"​")],-1)),i("details",A,[i("summary",null,[s[60]||(s[60]=i("a",{id:"SymbolicRegression.PopMemberModule.PopMember",href:"#SymbolicRegression.PopMemberModule.PopMember"},[i("span",{class:"jlbinding"},"SymbolicRegression.PopMemberModule.PopMember")],-1)),s[61]||(s[61]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[64]||(s[64]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PopMember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpression{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cost</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, loss</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a population member with a birth date at the current time. The type of the <code>Node</code> may be different from the type of the cost and loss.</p><p><strong>Arguments</strong></p><ul><li><p><code>t::AbstractExpression{T}</code>: The tree for the population member.</p></li><li><p><code>cost::L</code>: The cost (normalized to a baseline, and offset by a complexity penalty)</p></li><li><p><code>loss::L</code>: The raw loss to assign.</p></li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[62]||(s[62]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/PopMember.jl#L62-L74",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),s[65]||(s[65]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PopMember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dataset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dataset{T,L}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpression{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOptions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a population member with a birth date at the current time. Automatically compute the cost for this tree.</p><p><strong>Arguments</strong></p><ul><li><p><code>dataset::Dataset{T,L}</code>: The dataset to evaluate the tree on.</p></li><li><p><code>t::AbstractExpression{T}</code>: The tree for the population member.</p></li><li><p><code>options::AbstractOptions</code>: What options to use.</p></li></ul>`,4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[63]||(s[63]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/PopMember.jl#L107-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[97]||(s[97]=i("h2",{id:"Hall-of-Fame",tabindex:"-1"},[e("Hall of Fame "),i("a",{class:"header-anchor",href:"#Hall-of-Fame","aria-label":'Permalink to "Hall of Fame {#Hall-of-Fame}"'},"​")],-1)),i("details",D,[i("summary",null,[s[66]||(s[66]=i("a",{id:"SymbolicRegression.HallOfFameModule.HallOfFame",href:"#SymbolicRegression.HallOfFameModule.HallOfFame"},[i("span",{class:"jlbinding"},"SymbolicRegression.HallOfFameModule.HallOfFame")],-1)),s[67]||(s[67]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[69]||(s[69]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HallOfFame{T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DATA_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LOSS_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpression{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>List of the best members seen all time in <code>.members</code>, with <code>.members[c]</code> being the best member seen at complexity c. Including only the members which actually have been set, you can run <code>.members[exists]</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>members::Array{PopMember{T,L,N},1}</code>: List of the best members seen all time. These are ordered by complexity, with <code>.members[1]</code> the member with complexity 1.</p></li><li><p><code>exists::Array{Bool,1}</code>: Whether the member at the given complexity has been set.</p></li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[68]||(s[68]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/HallOfFame.jl#L13-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[98]||(s[98]=i("h2",{id:"Dataset",tabindex:"-1"},[e("Dataset "),i("a",{class:"header-anchor",href:"#Dataset","aria-label":'Permalink to "Dataset {#Dataset}"'},"​")],-1)),i("details",v,[i("summary",null,[s[70]||(s[70]=i("a",{id:"SymbolicRegression.CoreModule.DatasetModule.Dataset",href:"#SymbolicRegression.CoreModule.DatasetModule.Dataset"},[i("span",{class:"jlbinding"},"SymbolicRegression.CoreModule.DatasetModule.Dataset")],-1)),s[71]||(s[71]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[73]||(s[73]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dataset{T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DATA_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LOSS_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Abstract type for all dataset types in SymbolicRegression.jl.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[72]||(s[72]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/Dataset.jl#L10-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",j,[i("summary",null,[s[74]||(s[74]=i("a",{id:"SymbolicRegression.LossFunctionsModule.update_baseline_loss!",href:"#SymbolicRegression.LossFunctionsModule.update_baseline_loss!"},[i("span",{class:"jlbinding"},"SymbolicRegression.LossFunctionsModule.update_baseline_loss!")],-1)),s[75]||(s[75]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[77]||(s[77]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_baseline_loss!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dataset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dataset{T,L}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DATA_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LOSS_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Update the baseline loss of the dataset using the loss function specified in <code>options</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[76]||(s[76]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/66fbf2061fbf322282b81e56b6b3710a6369ee0b/src/LossFunctions.jl#L214-L218",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const I=o(d,[["render",S]]);export{L as __pageData,I as default};
