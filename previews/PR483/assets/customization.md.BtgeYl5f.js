import{_ as l,C as p,c as r,o as h,j as i,aA as n,a as e,G as a,w as o}from"./chunks/framework.DRv5kib6.js";const M=JSON.parse('{"title":"Customization","description":"","frontmatter":{},"headers":[],"relativePath":"customization.md","filePath":"customization.md","lastUpdated":null}'),d={name:"customization.md"},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""};function C(A,s,_,S,x,D){const t=p("Badge");return h(),r("div",null,[s[40]||(s[40]=i("h1",{id:"Customization",tabindex:"-1"},[e("Customization "),i("a",{class:"header-anchor",href:"#Customization","aria-label":'Permalink to "Customization {#Customization}"'},"​")],-1)),s[41]||(s[41]=i("p",null,"Many parts of SymbolicRegression.jl are designed to be customizable.",-1)),s[42]||(s[42]=i("p",null,"The normal way to do this in Julia is to define a new type that subtypes an abstract type from a package, and then define new methods for the type, extending internal methods on that type.",-1)),s[43]||(s[43]=i("h2",{id:"Custom-Options",tabindex:"-1"},[e("Custom Options "),i("a",{class:"header-anchor",href:"#Custom-Options","aria-label":'Permalink to "Custom Options {#Custom-Options}"'},"​")],-1)),s[44]||(s[44]=i("p",null,"For example, you can define a custom options type:",-1)),i("details",k,[i("summary",null,[s[0]||(s[0]=i("a",{id:"SymbolicRegression.CoreModule.OptionsStructModule.AbstractOptions",href:"#SymbolicRegression.CoreModule.OptionsStructModule.AbstractOptions"},[i("span",{class:"jlbinding"},"SymbolicRegression.CoreModule.OptionsStructModule.AbstractOptions")],-1)),s[1]||(s[1]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[3]||(s[3]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractOptions</span></span></code></pre></div><p>An abstract type that stores all search hyperparameters for SymbolicRegression.jl. The standard implementation is <a href="/SymbolicRegression.jl/previews/PR483/api#Options"><code>Options</code></a>.</p><p>You may wish to create a new subtypes of <code>AbstractOptions</code> to override certain functions or create new behavior. Ensure that this new type has all properties of <a href="/SymbolicRegression.jl/previews/PR483/api#Options"><code>Options</code></a>.</p><p>For example, if we have new options that we want to add to <code>Options</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@kwdef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyNewOptions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>we can create a combined options type that forwards properties to each corresponding type:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyOptions{O</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SymbolicRegression.Options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SymbolicRegression.AbstractOptions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    new_options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyNewOptions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sr_options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">O</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NEW_OPTIONS_KEYS </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fieldnames</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyNewOptions)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Constructor with both sets of parameters:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; kws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    new_options_keys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NEW_OPTIONS_KEYS, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kws))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    new_options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyNewOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(new_options_keys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kws[k] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> new_options_keys))</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sr_options_keys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NEW_OPTIONS_KEYS), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kws))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sr_options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SymbolicRegression</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sr_options_keys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kws[k] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sr_options_keys))</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(new_options, sr_options)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Make all \`Options\` available while also making \`new_options\` accessible</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getproperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NEW_OPTIONS_KEYS</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getproperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getfield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:new_options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getproperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getfield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:sr_options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">propertynames</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (NEW_OPTIONS_KEYS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fieldnames</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SymbolicRegression</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Options)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>which would let you access <code>a</code> and <code>b</code> from <code>MyOptions</code> objects, as well as making all properties of <code>Options</code> available for internal methods in SymbolicRegression.jl</p>`,8)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[2]||(s[2]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/OptionsStruct.jl#L115-L165",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),s[45]||(s[45]=i("p",null,"Any function in SymbolicRegression.jl you can generally define a new method on your custom options type, to define custom behavior.",-1)),s[46]||(s[46]=i("h2",{id:"Custom-Mutations",tabindex:"-1"},[e("Custom Mutations "),i("a",{class:"header-anchor",href:"#Custom-Mutations","aria-label":'Permalink to "Custom Mutations {#Custom-Mutations}"'},"​")],-1)),s[47]||(s[47]=i("p",null,[e("You can define custom mutation operators by defining a new method on "),i("code",null,"mutate!"),e(", as well as subtyping "),i("code",null,"AbstractMutationWeights"),e(":")],-1)),i("details",c,[i("summary",null,[s[4]||(s[4]=i("a",{id:"SymbolicRegression.MutateModule.mutate!",href:"#SymbolicRegression.MutateModule.mutate!"},[i("span",{class:"jlbinding"},"SymbolicRegression.MutateModule.mutate!")],-1)),s[5]||(s[5]=e()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[7]||(s[7]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mutate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">N</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    member</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{S}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mutation_weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMutationWeights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,P</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PopMember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,S}</span></span></code></pre></div><p>Perform a mutation on the given <code>tree</code> and <code>member</code> using the specified mutation type <code>S</code>. Various <code>kws</code> are provided to access other data needed for some mutations.</p><p>You may overload this function to handle new mutation types for new <code>AbstractMutationWeights</code> types.</p><p><strong>Keywords</strong></p><ul><li><p><code>temperature</code>: The temperature parameter for annealing-based mutations.</p></li><li><p><code>dataset::Dataset</code>: The dataset used for scoring.</p></li><li><p><code>cost</code>: The cost of the member before mutation.</p></li><li><p><code>loss</code>: The loss of the member before mutation.</p></li><li><p><code>curmaxsize</code>: The current maximum size constraint, which may be different from <code>options.maxsize</code>.</p></li><li><p><code>nfeatures</code>: The number of features in the dataset.</p></li><li><p><code>parent_ref</code>: Reference to the mutated member&#39;s parent (only used for logging purposes).</p></li><li><p><code>recorder::RecordType</code>: A recorder to log mutation details.</p></li></ul><p><strong>Returns</strong></p><p>A <code>MutationResult{N,P}</code> object containing the mutated tree or member (but not both), the number of evaluations performed, if any, and whether to return immediately from the mutation function, or to let the <code>next_generation</code> function handle accepting or rejecting the mutation. For example, a <code>simplify</code> operation will not change the loss, so it can always return immediately.</p>`,7)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[6]||(s[6]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/Mutate.jl#L381-L414",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),i("details",u,[i("summary",null,[s[8]||(s[8]=i("a",{id:"SymbolicRegression.CoreModule.MutationWeightsModule.AbstractMutationWeights",href:"#SymbolicRegression.CoreModule.MutationWeightsModule.AbstractMutationWeights"},[i("span",{class:"jlbinding"},"SymbolicRegression.CoreModule.MutationWeightsModule.AbstractMutationWeights")],-1)),s[9]||(s[9]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[11]||(s[11]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractMutationWeights</span></span></code></pre></div><p>An abstract type that defines the interface for mutation weight structures in the symbolic regression framework. Subtypes of <code>AbstractMutationWeights</code> specify how often different mutation operations occur during the mutation process.</p><p>You can create custom mutation weight types by subtyping <code>AbstractMutationWeights</code> and defining your own mutation operations. Additionally, you can overload the <code>sample_mutation</code> function to handle sampling from your custom mutation types.</p><p><strong>Usage</strong></p><p>To create a custom mutation weighting scheme with new mutation types, define a new subtype of <code>AbstractMutationWeights</code> and implement the necessary fields. Here&#39;s an example using <code>Base.@kwdef</code> to define the struct with default values:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SymbolicRegression</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractMutationWeights</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define custom mutation weights with default values</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@kwdef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyMutationWeights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractMutationWeights</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mutate_constant</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mutate_operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    custom_mutation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.7</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Next, overload the <code>sample_mutation</code> function to include your custom mutation types:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define the list of mutation names (symbols)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MY_MUTATIONS </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    :mutate_constant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    :mutate_operator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    :custom_mutation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Import the \`sample_mutation\` function to overload it</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SymbolicRegression</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sample_mutation</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StatsBase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StatsBase</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Overload the \`sample_mutation\` function</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sample_mutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyMutationWeights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutate_constant,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutate_operator,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">custom_mutation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">./</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weights)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Normalize weights to sum to 1.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StatsBase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MY_MUTATIONS, StatsBase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Weights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weights))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Pass it when defining \`Options\`:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SymbolicRegression</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Options</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutation_weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyMutationWeights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>This allows you to customize the mutation sampling process to include your custom mutations according to their specified weights.</p><p>To integrate your custom mutations into the mutation process, ensure that the mutation functions corresponding to your custom mutation types are defined and properly registered with the symbolic regression framework. You may need to define methods for <code>mutate!</code> that handle your custom mutation types.</p><p><strong>See Also</strong></p><ul><li><p><a href="/SymbolicRegression.jl/previews/PR483/api#SymbolicRegression.CoreModule.MutationWeightsModule.MutationWeights"><code>MutationWeights</code></a>: A concrete implementation of <code>AbstractMutationWeights</code> that defines default mutation weightings.</p></li><li><p><a href="/SymbolicRegression.jl/previews/PR483/customization#SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation"><code>sample_mutation</code></a>: Function to sample a mutation based on current mutation weights.</p></li><li><p><a href="/SymbolicRegression.jl/previews/PR483/customization#SymbolicRegression.MutateModule.mutate!"><code>mutate!</code></a>: Function to apply a mutation to an expression tree.</p></li><li><p><a href="./@ref SymbolicRegression.OptionsStruct.AbstractOptions"><code>AbstractOptions</code></a>: See how to extend abstract types for customizing options.</p></li></ul>`,12)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[10]||(s[10]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/MutationWeights.jl#L5-L67",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),i("details",g,[i("summary",null,[s[12]||(s[12]=i("a",{id:"SymbolicRegression.MutateModule.condition_mutation_weights!",href:"#SymbolicRegression.MutateModule.condition_mutation_weights!"},[i("span",{class:"jlbinding"},"SymbolicRegression.MutateModule.condition_mutation_weights!")],-1)),s[13]||(s[13]=e()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[15]||(s[15]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">condition_mutation_weights!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMutationWeights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, member</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PopMember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, curmaxsize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nfeatures</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Adjusts the mutation weights based on the properties of the current member and options.</p><p>This function modifies the mutation weights to ensure that the mutations applied to the member are appropriate given its current state and the provided options. It can be overloaded to customize the behavior for different types of expressions or members.</p><p>Note that the weights were already copied, so you don&#39;t need to worry about mutation.</p><p><strong>Arguments</strong></p><ul><li><p><code>weights::AbstractMutationWeights</code>: The mutation weights to be adjusted.</p></li><li><p><code>member::PopMember</code>: The current population member being mutated.</p></li><li><p><code>options::AbstractOptions</code>: The options that guide the mutation process.</p></li><li><p><code>curmaxsize::Int</code>: The current maximum size constraint for the member&#39;s expression tree.</p></li><li><p><code>nfeatures::Int</code>: The number of features available in the dataset.</p></li></ul>',6)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[14]||(s[14]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/Mutate.jl#L85-L100",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),i("details",y,[i("summary",null,[s[16]||(s[16]=i("a",{id:"SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation",href:"#SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation"},[i("span",{class:"jlbinding"},"SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation")],-1)),s[17]||(s[17]=e()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[19]||(s[19]=i("p",null,"Sample a mutation, given the weightings.",-1)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[18]||(s[18]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/MutationWeights.jl#L135",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),i("details",E,[i("summary",null,[s[20]||(s[20]=i("a",{id:"SymbolicRegression.MutateModule.MutationResult",href:"#SymbolicRegression.MutateModule.MutationResult"},[i("span",{class:"jlbinding"},"SymbolicRegression.MutateModule.MutationResult")],-1)),s[21]||(s[21]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[23]||(s[23]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MutationResult{N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,P</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PopMember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Represents the result of a mutation operation in the genetic programming algorithm. This struct is used to return values from <code>mutate!</code> functions.</p><p><strong>Fields</strong></p><ul><li><p><code>tree::Union{N, Nothing}</code>: The mutated expression tree, if applicable. Either <code>tree</code> or <code>member</code> must be set, but not both.</p></li><li><p><code>member::Union{P, Nothing}</code>: The mutated population member, if applicable. Either <code>member</code> or <code>tree</code> must be set, but not both.</p></li><li><p><code>num_evals::Float64</code>: The number of evaluations performed during the mutation, which is automatically set to <code>0.0</code>. Only used for things like <code>optimize</code>.</p></li><li><p><code>return_immediately::Bool</code>: If <code>true</code>, the mutation process should return immediately, bypassing further checks, used for things like <code>simplify</code> or <code>optimize</code> where you already know the loss value of the result.</p></li></ul><p><strong>Usage</strong></p><p>This struct encapsulates the result of a mutation operation. Either a new expression tree or a new population member is returned, but not both.</p><p>Return the <code>member</code> if you want to return immediately, and have computed the loss value as part of the mutation.</p>',7)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[22]||(s[22]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/Mutate.jl#L45-L63",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]})]),s[48]||(s[48]=i("h2",{id:"Custom-Expressions",tabindex:"-1"},[e("Custom Expressions "),i("a",{class:"header-anchor",href:"#Custom-Expressions","aria-label":'Permalink to "Custom Expressions {#Custom-Expressions}"'},"​")],-1)),s[49]||(s[49]=i("p",null,[e("You can create your own expression types by defining a new type that extends "),i("code",null,"AbstractExpression"),e(".")],-1)),i("details",m,[i("summary",null,[s[24]||(s[24]=i("a",{id:"DynamicExpressions.ExpressionModule.AbstractExpression",href:"#DynamicExpressions.ExpressionModule.AbstractExpression"},[i("span",{class:"jlbinding"},"DynamicExpressions.ExpressionModule.AbstractExpression")],-1)),s[25]||(s[25]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[27]||(s[27]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractExpression{T,N}</span></span></code></pre></div><p>(Experimental) Abstract type for user-facing expression types, which contain both the raw expression tree operating on a value type of <code>T</code>, as well as associated metadata to evaluate and render the expression.</p><p>See <a href="/SymbolicRegression.jl/previews/PR483/customization#DynamicExpressions.InterfacesModule.ExpressionInterface"><code>ExpressionInterface</code></a> for a full description of the interface implementation, as well as tests to verify correctness.</p><p>If you wish to use <code>@parse_expression</code>, you can also customize the parsing behavior with</p><ul><li><code>parse_leaf</code></li></ul>',5)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[26]||(s[26]=[i("a",{href:"https://github.com/SymbolicML/DynamicExpressions.jl/blob/v2.3.0/src/Expression.jl#L54-L68",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[26]})]),s[50]||(s[50]=i("p",null,[e("The interface is fairly flexible, and permits you define specific functional forms, extra parameters, etc. See the documentation of DynamicExpressions.jl for more details on what methods you need to implement. You can test the implementation of a given interface by using "),i("code",null,"ExpressionInterface"),e(" which makes use of "),i("code",null,"Interfaces.jl"),e(":")],-1)),i("details",b,[i("summary",null,[s[28]||(s[28]=i("a",{id:"DynamicExpressions.InterfacesModule.ExpressionInterface",href:"#DynamicExpressions.InterfacesModule.ExpressionInterface"},[i("span",{class:"jlbinding"},"DynamicExpressions.InterfacesModule.ExpressionInterface")],-1)),s[29]||(s[29]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[31]||(s[31]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ExpressionInterface</span></span></code></pre></div><p>An Interfaces.jl <code>Interface</code> with mandatory components <code>(:get_contents, :get_metadata, :get_tree, :get_operators, :get_variable_names, :copy, :with_contents, :with_metadata)</code> and optional components <code>(:copy_into!, :count_nodes, :count_constant_nodes, :count_depth, :index_constant_nodes, :has_operators, :has_constants, :get_scalar_constants, :set_scalar_constants!, :string_tree, :default_node_type, :constructorof, :tree_mapreduce)</code>.</p><p>Defines the interface of <a href="/SymbolicRegression.jl/previews/PR483/customization#DynamicExpressions.ExpressionModule.AbstractExpression"><code>AbstractExpression</code></a> for user-facing expression types, which can store operators, extra parameters, functional forms, variable names, etc.</p><p><strong>Extended help</strong></p><p><strong>Mandatory keys:</strong></p><ul><li><p><code>get_contents</code>: extracts the runtime contents of an expression</p></li><li><p><code>get_metadata</code>: extracts the runtime metadata of an expression</p></li><li><p><code>get_tree</code>: extracts the expression tree from <a href="/SymbolicRegression.jl/previews/PR483/customization#DynamicExpressions.ExpressionModule.AbstractExpression"><code>AbstractExpression</code></a></p></li><li><p><code>get_operators</code>: returns the operators used in the expression (or pass <code>operators</code> explicitly to override)</p></li><li><p><code>get_variable_names</code>: returns the variable names used in the expression (or pass <code>variable_names</code> explicitly to override)</p></li><li><p><code>copy</code>: returns a copy of the expression</p></li><li><p><code>with_contents</code>: returns the expression with different tree</p></li><li><p><code>with_metadata</code>: returns the expression with different metadata</p></li></ul><p><strong>Optional keys:</strong></p><ul><li><p><code>copy_into!</code>: copies an expression into a preallocated container</p></li><li><p><code>count_nodes</code>: counts the number of nodes in the expression tree</p></li><li><p><code>count_constant_nodes</code>: counts the number of constant nodes in the expression tree</p></li><li><p><code>count_depth</code>: calculates the depth of the expression tree</p></li><li><p><code>index_constant_nodes</code>: indexes constants in the expression tree</p></li><li><p><code>has_operators</code>: checks if the expression has operators</p></li><li><p><code>has_constants</code>: checks if the expression has constants</p></li><li><p><code>get_scalar_constants</code>: gets constants from the expression tree, returning a tuple of: (1) a flat vector of the constants, and (2) an reference object that can be used by <code>set_scalar_constants!</code> to efficiently set them back</p></li><li><p><code>set_scalar_constants!</code>: sets constants in the expression tree, given: (1) a flat vector of constants, (2) the expression, and (3) the reference object produced by <code>get_scalar_constants</code></p></li><li><p><code>string_tree</code>: returns a string representation of the expression tree</p></li><li><p><code>default_node_type</code>: returns the default node type for the expression</p></li><li><p><code>constructorof</code>: gets the constructor function for a type</p></li><li><p><code>tree_mapreduce</code>: applies a function across the tree</p></li></ul>',8)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[30]||(s[30]=[i("a",{href:"https://github.com/rafaqz/Interfaces.jl/blob/v0.3.2/src/interface.jl#L86-L94",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),s[51]||(s[51]=n('<p>Then, for SymbolicRegression.jl, you would pass <code>expression_type</code> to the <code>Options</code> constructor, as well as any <code>expression_options</code> you need (as a <code>NamedTuple</code>).</p><p>If needed, you may need to overload <code>SymbolicRegression.ExpressionBuilder.extra_init_params</code> in case your expression needs additional parameters. See the method for <code>ParametricExpression</code> as an example.</p><p>You can look at the files <code>src/ParametricExpression.jl</code> and <code>src/TemplateExpression.jl</code> for more examples of custom expression types, though note that <code>ParametricExpression</code> itself is defined in DynamicExpressions.jl, while that file just overloads some methods for SymbolicRegression.jl.</p><h2 id="Other-Customizations" tabindex="-1">Other Customizations <a class="header-anchor" href="#Other-Customizations" aria-label="Permalink to &quot;Other Customizations {#Other-Customizations}&quot;">​</a></h2><p>Other internal abstract types include the following:</p>',5)),i("details",f,[i("summary",null,[s[32]||(s[32]=i("a",{id:"SymbolicRegression.SearchUtilsModule.AbstractRuntimeOptions",href:"#SymbolicRegression.SearchUtilsModule.AbstractRuntimeOptions"},[i("span",{class:"jlbinding"},"SymbolicRegression.SearchUtilsModule.AbstractRuntimeOptions")],-1)),s[33]||(s[33]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[35]||(s[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractRuntimeOptions</span></span></code></pre></div><p>An abstract type representing runtime configuration parameters for the symbolic regression algorithm.</p><p><code>AbstractRuntimeOptions</code> is used by <code>equation_search</code> to control runtime aspects such as parallelism and iteration limits. By subtyping <code>AbstractRuntimeOptions</code>, advanced users can customize runtime behaviors by passing it to <code>equation_search</code>.</p><p><strong>See Also</strong></p><ul><li><p><a href="./@ref"><code>RuntimeOptions</code></a>: Default implementation used by <code>equation_search</code>.</p></li><li><p><a href="/SymbolicRegression.jl/previews/PR483/api#SymbolicRegression.equation_search"><code>equation_search</code></a>: Main function to perform symbolic regression.</p></li><li><p><a href="./@ref SymbolicRegression.CoreModule.OptionsStruct.AbstractOptions"><code>AbstractOptions</code></a>: See how to extend abstract types for customizing options.</p></li></ul>',5)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[34]||(s[34]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/SearchUtils.jl#L54-L69",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[34]})]),i("details",F,[i("summary",null,[s[36]||(s[36]=i("a",{id:"SymbolicRegression.SearchUtilsModule.AbstractSearchState",href:"#SymbolicRegression.SearchUtilsModule.AbstractSearchState"},[i("span",{class:"jlbinding"},"SymbolicRegression.SearchUtilsModule.AbstractSearchState")],-1)),s[37]||(s[37]=e()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[39]||(s[39]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSearchState{T,L,N}</span></span></code></pre></div><p>An abstract type encapsulating the internal state of the search process during symbolic regression.</p><p><code>AbstractSearchState</code> instances hold information like populations and progress metrics, used internally by <code>equation_search</code>. Subtyping <code>AbstractSearchState</code> allows customization of search state management.</p><p>Look through the source of <code>equation_search</code> to see how this is used.</p><p><strong>See Also</strong></p><ul><li><p><a href="./@ref"><code>SearchState</code></a>: Default implementation of <code>AbstractSearchState</code>.</p></li><li><p><a href="/SymbolicRegression.jl/previews/PR483/api#SymbolicRegression.equation_search"><code>equation_search</code></a>: Function where <code>AbstractSearchState</code> is utilized.</p></li><li><p><a href="./@ref SymbolicRegression.CoreModule.OptionsStruct.AbstractOptions"><code>AbstractOptions</code></a>: See how to extend abstract types for customizing options.</p></li></ul>',6)),a(t,{type:"info",class:"source-link",text:"source"},{default:o(()=>s[38]||(s[38]=[i("a",{href:"https://github.com/MilesCranmer/SymbolicRegression.jl/blob/521990fa40111ccebb680ebb206946ed461b4fe4/src/SearchUtils.jl#L548-L565",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[38]})]),s[52]||(s[52]=i("p",null,"These let you include custom state variables and runtime options.",-1))])}const T=l(d,[["render",C]]);export{M as __pageData,T as default};
