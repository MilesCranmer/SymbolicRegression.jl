<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Customization · SymbolicRegression.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ai.damtp.cam.ac.uk/symbolicregression/stable/customization/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index_base/"><img src="../assets/logo.svg" alt="SymbolicRegression.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index_base/">SymbolicRegression.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index_base/">Contents</a></li><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/">Short Examples</a></li><li><a class="tocitem" href="../examples/template_expression/">Template Expressions</a></li><li><a class="tocitem" href="../examples/parameterized_function/">Parameterized Expressions</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../losses/">Losses</a></li><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Customization</a><ul class="internal"><li><a class="tocitem" href="#Custom-Options"><span>Custom Options</span></a></li><li><a class="tocitem" href="#Custom-Mutations"><span>Custom Mutations</span></a></li><li><a class="tocitem" href="#Custom-Expressions"><span>Custom Expressions</span></a></li><li><a class="tocitem" href="#Other-Customizations"><span>Other Customizations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Customization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Customization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/master/docs/src/customization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Customization"><a class="docs-heading-anchor" href="#Customization">Customization</a><a id="Customization-1"></a><a class="docs-heading-anchor-permalink" href="#Customization" title="Permalink"></a></h1><p>Many parts of SymbolicRegression.jl are designed to be customizable.</p><p>The normal way to do this in Julia is to define a new type that subtypes an abstract type from a package, and then define new methods for the type, extending internal methods on that type.</p><h2 id="Custom-Options"><a class="docs-heading-anchor" href="#Custom-Options">Custom Options</a><a id="Custom-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Options" title="Permalink"></a></h2><p>For example, you can define a custom options type:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.CoreModule.OptionsStructModule.AbstractOptions" href="#SymbolicRegression.CoreModule.OptionsStructModule.AbstractOptions"><code>SymbolicRegression.CoreModule.OptionsStructModule.AbstractOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOptions</code></pre><p>An abstract type that stores all search hyperparameters for SymbolicRegression.jl. The standard implementation is <a href="../api/#SymbolicRegression.CoreModule.OptionsStructModule.Options"><code>Options</code></a>.</p><p>You may wish to create a new subtypes of <code>AbstractOptions</code> to override certain functions or create new behavior. Ensure that this new type has all properties of <a href="../api/#SymbolicRegression.CoreModule.OptionsStructModule.Options"><code>Options</code></a>.</p><p>For example, if we have new options that we want to add to <code>Options</code>:</p><pre><code class="language-julia hljs">Base.@kwdef struct MyNewOptions
    a::Float64 = 1.0
    b::Int = 3
end</code></pre><p>we can create a combined options type that forwards properties to each corresponding type:</p><pre><code class="language-julia hljs">struct MyOptions{O&lt;:SymbolicRegression.Options} &lt;: SymbolicRegression.AbstractOptions
    new_options::MyNewOptions
    sr_options::O
end
const NEW_OPTIONS_KEYS = fieldnames(MyNewOptions)

# Constructor with both sets of parameters:
function MyOptions(; kws...)
    new_options_keys = filter(k -&gt; k in NEW_OPTIONS_KEYS, keys(kws))
    new_options = MyNewOptions(; NamedTuple(new_options_keys .=&gt; Tuple(kws[k] for k in new_options_keys))...)
    sr_options_keys = filter(k -&gt; !(k in NEW_OPTIONS_KEYS), keys(kws))
    sr_options = SymbolicRegression.Options(; NamedTuple(sr_options_keys .=&gt; Tuple(kws[k] for k in sr_options_keys))...)
    return MyOptions(new_options, sr_options)
end

# Make all `Options` available while also making `new_options` accessible
function Base.getproperty(options::MyOptions, k::Symbol)
    if k in NEW_OPTIONS_KEYS
        return getproperty(getfield(options, :new_options), k)
    else
        return getproperty(getfield(options, :sr_options), k)
    end
end

Base.propertynames(options::MyOptions) = (NEW_OPTIONS_KEYS..., fieldnames(SymbolicRegression.Options)...)</code></pre><p>which would let you access <code>a</code> and <code>b</code> from <code>MyOptions</code> objects, as well as making all properties of <code>Options</code> available for internal methods in SymbolicRegression.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/OptionsStruct.jl#L127-L177">source</a></section></article><p>Any function in SymbolicRegression.jl you can generally define a new method on your custom options type, to define custom behavior.</p><h2 id="Custom-Mutations"><a class="docs-heading-anchor" href="#Custom-Mutations">Custom Mutations</a><a id="Custom-Mutations-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Mutations" title="Permalink"></a></h2><p>You can define custom mutation operators by defining a new method on <code>mutate!</code>, as well as subtyping <code>AbstractMutationWeights</code>:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.MutateModule.mutate!" href="#SymbolicRegression.MutateModule.mutate!"><code>SymbolicRegression.MutateModule.mutate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mutate!(
    tree::N,
    member::P,
    ::Val{S},
    mutation_weights::AbstractMutationWeights,
    options::AbstractOptions;
    kws...,
) where {N&lt;:AbstractExpression,P&lt;:PopMember,S}</code></pre><p>Perform a mutation on the given <code>tree</code> and <code>member</code> using the specified mutation type <code>S</code>. Various <code>kws</code> are provided to access other data needed for some mutations.</p><p>You may overload this function to handle new mutation types for new <code>AbstractMutationWeights</code> types.</p><p><strong>Keywords</strong></p><ul><li><code>temperature</code>: The temperature parameter for annealing-based mutations.</li><li><code>dataset::Dataset</code>: The dataset used for scoring.</li><li><code>score</code>: The score of the member before mutation.</li><li><code>loss</code>: The loss of the member before mutation.</li><li><code>curmaxsize</code>: The current maximum size constraint, which may be different from <code>options.maxsize</code>.</li><li><code>nfeatures</code>: The number of features in the dataset.</li><li><code>parent_ref</code>: Reference to the mutated member&#39;s parent (only used for logging purposes).</li><li><code>recorder::RecordType</code>: A recorder to log mutation details.</li></ul><p><strong>Returns</strong></p><p>A <code>MutationResult{N,P}</code> object containing the mutated tree or member (but not both), the number of evaluations performed, if any, and whether to return immediately from the mutation function, or to let the <code>next_generation</code> function handle accepting or rejecting the mutation. For example, a <code>simplify</code> operation will not change the loss, so it can always return immediately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/Mutate.jl#L369-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.CoreModule.MutationWeightsModule.AbstractMutationWeights" href="#SymbolicRegression.CoreModule.MutationWeightsModule.AbstractMutationWeights"><code>SymbolicRegression.CoreModule.MutationWeightsModule.AbstractMutationWeights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMutationWeights</code></pre><p>An abstract type that defines the interface for mutation weight structures in the symbolic regression framework. Subtypes of <code>AbstractMutationWeights</code> specify how often different mutation operations occur during the mutation process.</p><p>You can create custom mutation weight types by subtyping <code>AbstractMutationWeights</code> and defining your own mutation operations. Additionally, you can overload the <code>sample_mutation</code> function to handle sampling from your custom mutation types.</p><p><strong>Usage</strong></p><p>To create a custom mutation weighting scheme with new mutation types, define a new subtype of <code>AbstractMutationWeights</code> and implement the necessary fields. Here&#39;s an example using <code>Base.@kwdef</code> to define the struct with default values:</p><pre><code class="language-julia hljs">using SymbolicRegression: AbstractMutationWeights

# Define custom mutation weights with default values
Base.@kwdef struct MyMutationWeights &lt;: AbstractMutationWeights
    mutate_constant::Float64 = 0.1
    mutate_operator::Float64 = 0.2
    custom_mutation::Float64 = 0.7
end</code></pre><p>Next, overload the <code>sample_mutation</code> function to include your custom mutation types:</p><pre><code class="language-julia hljs"># Define the list of mutation names (symbols)
const MY_MUTATIONS = [
    :mutate_constant,
    :mutate_operator,
    :custom_mutation
]

# Import the `sample_mutation` function to overload it
import SymbolicRegression: sample_mutation
using StatsBase: StatsBase

# Overload the `sample_mutation` function
function sample_mutation(w::MyMutationWeights)
    weights = [
        w.mutate_constant,
        w.mutate_operator,
        w.custom_mutation
    ]
    weights = weights ./ sum(weights)  # Normalize weights to sum to 1.0
    return StatsBase.sample(MY_MUTATIONS, StatsBase.Weights(weights))
end

# Pass it when defining `Options`:
using SymbolicRegression: Options
options = Options(mutation_weights=MyMutationWeights())</code></pre><p>This allows you to customize the mutation sampling process to include your custom mutations according to their specified weights.</p><p>To integrate your custom mutations into the mutation process, ensure that the mutation functions corresponding to your custom mutation types are defined and properly registered with the symbolic regression framework. You may need to define methods for <code>mutate!</code> that handle your custom mutation types.</p><p><strong>See Also</strong></p><ul><li><a href="../api/#SymbolicRegression.CoreModule.MutationWeightsModule.MutationWeights"><code>MutationWeights</code></a>: A concrete implementation of <code>AbstractMutationWeights</code> that defines default mutation weightings.</li><li><a href="#SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation"><code>sample_mutation</code></a>: Function to sample a mutation based on current mutation weights.</li><li><a href="@ref SymbolicRegression.MutateModule.mutate!"><code>mutate!</code></a>: Function to apply a mutation to an expression tree.</li><li><a href="@ref SymbolicRegression.OptionsStruct.AbstractOptions"><code>AbstractOptions</code></a>: See how to extend abstract types for customizing options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/MutationWeights.jl#L5-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.MutateModule.condition_mutation_weights!" href="#SymbolicRegression.MutateModule.condition_mutation_weights!"><code>SymbolicRegression.MutateModule.condition_mutation_weights!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">condition_mutation_weights!(weights::AbstractMutationWeights, member::PopMember, options::AbstractOptions, curmaxsize::Int)</code></pre><p>Adjusts the mutation weights based on the properties of the current member and options.</p><p>This function modifies the mutation weights to ensure that the mutations applied to the member are appropriate given its current state and the provided options. It can be overloaded to customize the behavior for different types of expressions or members.</p><p>Note that the weights were already copied, so you don&#39;t need to worry about mutation.</p><p><strong>Arguments</strong></p><ul><li><code>weights::AbstractMutationWeights</code>: The mutation weights to be adjusted.</li><li><code>member::PopMember</code>: The current population member being mutated.</li><li><code>options::AbstractOptions</code>: The options that guide the mutation process.</li><li><code>curmaxsize::Int</code>: The current maximum size constraint for the member&#39;s expression tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/Mutate.jl#L80-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation" href="#SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation"><code>SymbolicRegression.CoreModule.MutationWeightsModule.sample_mutation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Sample a mutation, given the weightings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/MutationWeights.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.MutateModule.MutationResult" href="#SymbolicRegression.MutateModule.MutationResult"><code>SymbolicRegression.MutateModule.MutationResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MutationResult{N&lt;:AbstractExpression,P&lt;:PopMember}</code></pre><p>Represents the result of a mutation operation in the genetic programming algorithm. This struct is used to return values from <code>mutate!</code> functions.</p><p><strong>Fields</strong></p><ul><li><code>tree::Union{N, Nothing}</code>: The mutated expression tree, if applicable. Either <code>tree</code> or <code>member</code> must be set, but not both.</li><li><code>member::Union{P, Nothing}</code>: The mutated population member, if applicable. Either <code>member</code> or <code>tree</code> must be set, but not both.</li><li><code>num_evals::Float64</code>: The number of evaluations performed during the mutation, which is automatically set to <code>0.0</code>. Only used for things like <code>optimize</code>.</li><li><code>return_immediately::Bool</code>: If <code>true</code>, the mutation process should return immediately, bypassing further checks, used for things like <code>simplify</code> or <code>optimize</code> where you already know the loss value of the result.</li></ul><p><strong>Usage</strong></p><p>This struct encapsulates the result of a mutation operation. Either a new expression tree or a new population member is returned, but not both.</p><p>Return the <code>member</code> if you want to return immediately, and have computed the loss value as part of the mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/Mutate.jl#L40-L58">source</a></section></article><h2 id="Custom-Expressions"><a class="docs-heading-anchor" href="#Custom-Expressions">Custom Expressions</a><a id="Custom-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Expressions" title="Permalink"></a></h2><p>You can create your own expression types by defining a new type that extends <code>AbstractExpression</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.ExpressionModule.AbstractExpression" href="#DynamicExpressions.ExpressionModule.AbstractExpression"><code>DynamicExpressions.ExpressionModule.AbstractExpression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractExpression{T,N}</code></pre><p>(Experimental) Abstract type for user-facing expression types, which contain both the raw expression tree operating on a value type of <code>T</code>, as well as associated metadata to evaluate and render the expression.</p><p>See <a href="@ref DynamicExpressions.InterfacesModule.ExpressionInterface"><code>ExpressionInterface</code></a> for a full description of the interface implementation, as well as tests to verify correctness.</p><p>If you wish to use <code>@parse_expression</code>, you can also customize the parsing behavior with</p><ul><li><code>parse_leaf</code></li></ul></div></section></article><p>The interface is fairly flexible, and permits you define specific functional forms, extra parameters, etc. See the documentation of DynamicExpressions.jl for more details on what methods you need to implement. You can test the implementation of a given interface by using <code>ExpressionInterface</code> which makes use of <code>Interfaces.jl</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.InterfacesModule.ExpressionInterface" href="#DynamicExpressions.InterfacesModule.ExpressionInterface"><code>DynamicExpressions.InterfacesModule.ExpressionInterface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    ExpressionInterface</code></pre><p>An Interfaces.jl <code>Interface</code> with mandatory components <code>(:get_contents, :get_metadata, :get_tree, :get_operators, :get_variable_names, :copy, :with_contents, :with_metadata)</code> and optional components <code>(:count_nodes, :count_constant_nodes, :count_depth, :index_constant_nodes, :has_operators, :has_constants, :get_scalar_constants, :set_scalar_constants!, :string_tree, :default_node_type, :constructorof, :tree_mapreduce)</code>.</p><p>Defines the interface of <a href="#DynamicExpressions.ExpressionModule.AbstractExpression"><code>AbstractExpression</code></a> for user-facing expression types, which can store operators, extra parameters, functional forms, variable names, etc.</p><p><strong>Extended help</strong></p><p><strong>Mandatory keys:</strong></p><ul><li><code>get_contents</code>: extracts the runtime contents of an expression</li><li><code>get_metadata</code>: extracts the runtime metadata of an expression</li><li><code>get_tree</code>: extracts the expression tree from <a href="#DynamicExpressions.ExpressionModule.AbstractExpression"><code>AbstractExpression</code></a></li><li><code>get_operators</code>: returns the operators used in the expression (or pass <code>operators</code> explicitly to override)</li><li><code>get_variable_names</code>: returns the variable names used in the expression (or pass <code>variable_names</code> explicitly to override)</li><li><code>copy</code>: returns a copy of the expression</li><li><code>with_contents</code>: returns the expression with different tree</li><li><code>with_metadata</code>: returns the expression with different metadata</li></ul><p><strong>Optional keys:</strong></p><ul><li><code>count_nodes</code>: counts the number of nodes in the expression tree</li><li><code>count_constant_nodes</code>: counts the number of constant nodes in the expression tree</li><li><code>count_depth</code>: calculates the depth of the expression tree</li><li><code>index_constant_nodes</code>: indexes constants in the expression tree</li><li><code>has_operators</code>: checks if the expression has operators</li><li><code>has_constants</code>: checks if the expression has constants</li><li><code>get_scalar_constants</code>: gets constants from the expression tree, returning a tuple of: (1) a flat vector of the constants, and (2) an reference object that can be used by <code>set_scalar_constants!</code> to efficiently set them back</li><li><code>set_scalar_constants!</code>: sets constants in the expression tree, given: (1) a flat vector of constants, (2) the expression, and (3) the reference object produced by <code>get_scalar_constants</code></li><li><code>string_tree</code>: returns a string representation of the expression tree</li><li><code>default_node_type</code>: returns the default node type for the expression</li><li><code>constructorof</code>: gets the constructor function for a type</li><li><code>tree_mapreduce</code>: applies a function across the tree</li></ul></div></section></article><p>Then, for SymbolicRegression.jl, you would pass <code>expression_type</code> to the <code>Options</code> constructor, as well as any <code>expression_options</code> you need (as a <code>NamedTuple</code>).</p><p>If needed, you may need to overload <code>SymbolicRegression.ExpressionBuilder.extra_init_params</code> in case your expression needs additional parameters. See the method for <code>ParametricExpression</code> as an example.</p><p>You can look at the files <code>src/ParametricExpression.jl</code> and <code>src/TemplateExpression.jl</code> for more examples of custom expression types, though note that <code>ParametricExpression</code> itself is defined in DynamicExpressions.jl, while that file just overloads some methods for SymbolicRegression.jl.</p><h2 id="Other-Customizations"><a class="docs-heading-anchor" href="#Other-Customizations">Other Customizations</a><a id="Other-Customizations-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Customizations" title="Permalink"></a></h2><p>Other internal abstract types include the following:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.SearchUtilsModule.AbstractRuntimeOptions" href="#SymbolicRegression.SearchUtilsModule.AbstractRuntimeOptions"><code>SymbolicRegression.SearchUtilsModule.AbstractRuntimeOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRuntimeOptions</code></pre><p>An abstract type representing runtime configuration parameters for the symbolic regression algorithm.</p><p><code>AbstractRuntimeOptions</code> is used by <code>equation_search</code> to control runtime aspects such as parallelism and iteration limits. By subtyping <code>AbstractRuntimeOptions</code>, advanced users can customize runtime behaviors by passing it to <code>equation_search</code>.</p><p><strong>See Also</strong></p><ul><li><a href="@ref"><code>RuntimeOptions</code></a>: Default implementation used by <code>equation_search</code>.</li><li><a href="@ref SymbolicRegression.equation_search"><code>equation_search</code></a>: Main function to perform symbolic regression.</li><li><a href="@ref SymbolicRegression.CoreModule.OptionsStruct.AbstractOptions"><code>AbstractOptions</code></a>: See how to extend abstract types for customizing options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/SearchUtils.jl#L26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.SearchUtilsModule.AbstractSearchState" href="#SymbolicRegression.SearchUtilsModule.AbstractSearchState"><code>SymbolicRegression.SearchUtilsModule.AbstractSearchState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSearchState{T,L,N}</code></pre><p>An abstract type encapsulating the internal state of the search process during symbolic regression.</p><p><code>AbstractSearchState</code> instances hold information like populations and progress metrics, used internally by <code>equation_search</code>. Subtyping <code>AbstractSearchState</code> allows customization of search state management.</p><p>Look through the source of <code>equation_search</code> to see how this is used.</p><p><strong>See Also</strong></p><ul><li><a href="@ref"><code>SearchState</code></a>: Default implementation of <code>AbstractSearchState</code>.</li><li><a href="@ref SymbolicRegression.equation_search"><code>equation_search</code></a>: Function where <code>AbstractSearchState</code> is utilized.</li><li><a href="@ref SymbolicRegression.CoreModule.OptionsStruct.AbstractOptions"><code>AbstractOptions</code></a>: See how to extend abstract types for customizing options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/36acbc33a3f2817d406abd07a8dc082b36c6057c/src/SearchUtils.jl#L520-L537">source</a></section></article><p>These let you include custom state variables and runtime options.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 3 December 2024 22:48">Tuesday 3 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
