import{_ as l,c as i,o as t,j as s,aA as n,a as e}from"./chunks/framework.DvK8AXlI.js";const y=JSON.parse('{"title":"Learning Parameterized Expressions","description":"","frontmatter":{},"headers":[],"relativePath":"examples/parameterized_function.md","filePath":"examples/parameterized_function.md","lastUpdated":null}'),h={name:"examples/parameterized_function.md"},p={class:"MathJax",jax:"SVG",display:"true",style:{direction:"ltr",display:"block","text-align":"center",margin:"1em 0",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"81.084ex",height:"2.565ex",role:"img",focusable:"false",viewBox:"0 -883.9 35839.3 1133.9","aria-hidden":"true"};function r(d,a,T,Q,g,E){return t(),i("div",null,[a[2]||(a[2]=s("h1",{id:"Learning-Parameterized-Expressions",tabindex:"-1"},[e("Learning Parameterized Expressions "),s("a",{class:"header-anchor",href:"#Learning-Parameterized-Expressions","aria-label":'Permalink to "Learning Parameterized Expressions {#Learning-Parameterized-Expressions}"'},"​")],-1)),a[3]||(a[3]=s("p",null,[s("em",null,"Note: Parametric expressions are currently considered experimental and may change in the future.")],-1)),a[4]||(a[4]=s("p",null,"Parameterized expressions in SymbolicRegression.jl allow you to discover symbolic expressions that contain optimizable parameters. This is particularly useful when you have data that follows different patterns based on some categorical variable, or when you want to learn an expression with constants that should be optimized during the search.",-1)),a[5]||(a[5]=s("p",null,"In this tutorial, we'll generate synthetic data with class-dependent parameters and use symbolic regression to discover the parameterized expressions.",-1)),a[6]||(a[6]=s("h2",{id:"The-Problem",tabindex:"-1"},[e("The Problem "),s("a",{class:"header-anchor",href:"#The-Problem","aria-label":'Permalink to "The Problem {#The-Problem}"'},"​")],-1)),a[7]||(a[7]=s("p",null,"Let's create a synthetic dataset where the underlying function changes based on a class label:",-1)),s("mjx-container",p,[(t(),i("svg",k,a[0]||(a[0]=[n("",1)]))),a[1]||(a[1]=s("mjx-assistive-mml",{unselectable:"on",display:"block",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",overflow:"hidden",width:"100%"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("mi",null,"y"),s("mo",null,"="),s("mn",null,"2"),s("mi",null,"cos"),s("mo",{"data-mjx-texclass":"NONE"},"⁡"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mi",null,"x"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"0.1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("msubsup",null,[s("mi",null,"x"),s("mn",null,"1"),s("mn",null,"2")]),s("mo",null,"−"),s("mn",null,"3.2"),s("mtext",null," "),s("mtext",null," "),s("mtext",null," "),s("mtext",null," "),s("mtext",null,"[class 1]"),s("mspace",{linebreak:"newline"}),s("mtext",null,"OR"),s("mspace",{linebreak:"newline"}),s("mi",null,"y"),s("mo",null,"="),s("mn",null,"2"),s("mi",null,"cos"),s("mo",{"data-mjx-texclass":"NONE"},"⁡"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mi",null,"x"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"1.5"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("msubsup",null,[s("mi",null,"x"),s("mn",null,"1"),s("mn",null,"2")]),s("mo",null,"−"),s("mn",null,"0.5"),s("mtext",null," "),s("mtext",null," "),s("mtext",null," "),s("mtext",null," "),s("mtext",null,"[class 2]")])],-1))]),a[8]||(a[8]=n("",24))])}const c=l(h,[["render",r]]);export{y as __pageData,c as default};
