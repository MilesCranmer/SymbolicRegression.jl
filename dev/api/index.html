<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SymbolicRegression.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ai.damtp.cam.ac.uk/symbolicregression/stable/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index_base/"><img src="../assets/logo.svg" alt="SymbolicRegression.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index_base/">SymbolicRegression.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index_base/">Contents</a></li><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/">Short Examples</a></li><li><a class="tocitem" href="../examples/template_expression/">Template Expressions</a></li><li><a class="tocitem" href="../examples/parameterized_function/">Parameterized Expressions</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#MLJ-interface"><span>MLJ interface</span></a></li><li><a class="tocitem" href="#Low-Level-API"><span>Low-Level API</span></a></li><li><a class="tocitem" href="#Options"><span>Options</span></a></li><li><a class="tocitem" href="#Printing"><span>Printing</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li><li><a class="tocitem" href="#SymbolicUtils.jl-interface"><span>SymbolicUtils.jl interface</span></a></li><li><a class="tocitem" href="#Pareto-frontier"><span>Pareto frontier</span></a></li><li><a class="tocitem" href="#Logging"><span>Logging</span></a></li></ul></li><li><a class="tocitem" href="../losses/">Losses</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../customization/">Customization</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="MLJ-interface"><a class="docs-heading-anchor" href="#MLJ-interface">MLJ interface</a><a id="MLJ-interface-1"></a><a class="docs-heading-anchor-permalink" href="#MLJ-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.MLJInterfaceModule.SRRegressor" href="#SymbolicRegression.MLJInterfaceModule.SRRegressor"><code>SymbolicRegression.MLJInterfaceModule.SRRegressor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SRRegressor</code></pre><p>A model type for constructing a Symbolic Regression via Evolutionary Search, based on <a href="https://github.com/MilesCranmer/SymbolicRegression.jl">SymbolicRegression.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">SRRegressor = @load SRRegressor pkg=SymbolicRegression</code></pre><p>Do <code>model = SRRegressor()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>SRRegressor(defaults=...)</code>.</p><p>Single-target Symbolic Regression regressor (<code>SRRegressor</code>) searches for symbolic expressions that predict a single target variable from a set of input variables. All data is assumed to be <code>Continuous</code>. The search is performed using an evolutionary algorithm. This algorithm is described in the paper https://arxiv.org/abs/2305.01582.</p><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with</p><pre><code class="nohighlight hljs">mach = machine(model, X, y)</code></pre><p>OR</p><pre><code class="nohighlight hljs">mach = machine(model, X, y, w)</code></pre><p>Here:</p><ul><li><p><code>X</code> is any table of input features (eg, a <code>DataFrame</code>) whose columns are of scitype <code>Continuous</code>; check column scitypes with <code>schema(X)</code>. Variable names in discovered expressions will be taken from the column names of <code>X</code>, if available. Units in columns of <code>X</code> (use <code>DynamicQuantities</code> for units) will trigger dimensional analysis to be used.</p></li><li><p><code>y</code> is the target, which can be any <code>AbstractVector</code> whose element scitype is   <code>Continuous</code>; check the scitype with <code>scitype(y)</code>. Units in <code>y</code> (use <code>DynamicQuantities</code>   for units) will trigger dimensional analysis to be used.</p></li><li><p><code>w</code> is the observation weights which can either be <code>nothing</code> (default) or an <code>AbstractVector</code> whose element scitype is <code>Count</code> or <code>Continuous</code>.</p></li></ul><p>Train the machine using <code>fit!(mach)</code>, inspect the discovered expressions with <code>report(mach)</code>, and predict on new data with <code>predict(mach, Xnew)</code>. Note that unlike other regressors, symbolic regression stores a list of trained models. The model chosen from this list is defined by the function <code>selection_method</code> keyword argument, which by default balances accuracy and complexity. You can override this at prediction time by passing a named tuple with keys <code>data</code> and <code>idx</code>.</p><p><strong>Hyper-parameters</strong></p><ul><li><p><code>defaults</code>: What set of defaults to use for <code>Options</code>. The default,   <code>nothing</code>, will simply take the default options from the current version of SymbolicRegression.   However, you may also select the defaults from an earlier version, such as <code>v&quot;0.24.5&quot;</code>.</p></li><li><p><code>binary_operators</code>: Vector of binary operators (functions) to use.   Each operator should be defined for two input scalars,   and one output scalar. All operators   need to be defined over the entire real line (excluding infinity - these   are stopped before they are input), or return <code>NaN</code> where not defined.   For speed, define it so it takes two reals   of the same type as input, and outputs the same type. For the SymbolicUtils   simplification backend, you will need to define a generic method of the   operator so it takes arbitrary types.</p></li><li><p><code>unary_operators</code>: Same, but for   unary operators (one input scalar, gives an output scalar).</p></li><li><p><code>constraints</code>: Array of pairs specifying size constraints   for each operator. The constraints for a binary operator should be a 2-tuple   (e.g., <code>(-1, -1)</code>) and the constraints for a unary operator should be an <code>Int</code>.   A size constraint is a limit to the size of the subtree   in each argument of an operator. e.g., <code>[(^)=&gt;(-1, 3)]</code> means that the   <code>^</code> operator can have arbitrary size (<code>-1</code>) in its left argument,   but a maximum size of <code>3</code> in its right argument. Default is   no constraints.</p></li><li><p><code>batching</code>: Whether to evolve based on small mini-batches of data,   rather than the entire dataset.</p></li><li><p><code>batch_size</code>: What batch size to use if using batching.</p></li><li><p><code>elementwise_loss</code>: What elementwise loss function to use. Can be one of   the following losses, or any other loss of type   <code>SupervisedLoss</code>. You can also pass a function that takes   a scalar target (left argument), and scalar predicted (right   argument), and returns a scalar. This will be averaged   over the predicted data. If weights are supplied, your   function should take a third argument for the weight scalar.   Included losses:       Regression:           - <code>LPDistLoss{P}()</code>,           - <code>L1DistLoss()</code>,           - <code>L2DistLoss()</code> (mean square),           - <code>LogitDistLoss()</code>,           - <code>HuberLoss(d)</code>,           - <code>L1EpsilonInsLoss(ϵ)</code>,           - <code>L2EpsilonInsLoss(ϵ)</code>,           - <code>PeriodicLoss(c)</code>,           - <code>QuantileLoss(τ)</code>,       Classification:           - <code>ZeroOneLoss()</code>,           - <code>PerceptronLoss()</code>,           - <code>L1HingeLoss()</code>,           - <code>SmoothedL1HingeLoss(γ)</code>,           - <code>ModifiedHuberLoss()</code>,           - <code>L2MarginLoss()</code>,           - <code>ExpLoss()</code>,           - <code>SigmoidLoss()</code>,           - <code>DWDMarginLoss(q)</code>.</p></li><li><p><code>loss_function</code>: Alternatively, you may redefine the loss used   as any function of <code>tree::AbstractExpressionNode{T}</code>, <code>dataset::Dataset{T}</code>,   and <code>options::AbstractOptions</code>, so long as you output a non-negative   scalar of type <code>T</code>. This is useful if you want to use a loss   that takes into account derivatives, or correlations across   the dataset. This also means you could use a custom evaluation   for a particular expression. If you are using   <code>batching=true</code>, then your function should   accept a fourth argument <code>idx</code>, which is either <code>nothing</code>   (indicating that the full dataset should be used), or a vector   of indices to use for the batch.   For example,</p><pre><code class="nohighlight hljs">  function my_loss(tree, dataset::Dataset{T,L}, options)::L where {T,L}
      prediction, flag = eval_tree_array(tree, dataset.X, options)
      if !flag
          return L(Inf)
      end
      return sum((prediction .- dataset.y) .^ 2) / dataset.n
  end</code></pre></li><li><p><code>expression_type::Type{E}=Expression</code>: The type of expression to use.   For example, <code>Expression</code>.</p></li><li><p><code>node_type::Type{N}=default_node_type(Expression)</code>: The type of node to use for the search.   For example, <code>Node</code> or <code>GraphNode</code>. The default is computed by <code>default_node_type(expression_type)</code>.</p></li><li><p><code>populations</code>: How many populations of equations to use.</p></li><li><p><code>population_size</code>: How many equations in each population.</p></li><li><p><code>ncycles_per_iteration</code>: How many generations to consider per iteration.</p></li><li><p><code>tournament_selection_n</code>: Number of expressions considered in each tournament.</p></li><li><p><code>tournament_selection_p</code>: The fittest expression in a tournament is to be   selected with probability <code>p</code>, the next fittest with probability <code>p*(1-p)</code>,   and so forth.</p></li><li><p><code>topn</code>: Number of equations to return to the host process, and to   consider for the hall of fame.</p></li><li><p><code>complexity_of_operators</code>: What complexity should be assigned to each operator,   and the occurrence of a constant or variable. By default, this is 1   for all operators. Can be a real number as well, in which case   the complexity of an expression will be rounded to the nearest integer.   Input this in the form of, e.g., [(^) =&gt; 3, sin =&gt; 2].</p></li><li><p><code>complexity_of_constants</code>: What complexity should be assigned to use of a constant.   By default, this is 1.</p></li><li><p><code>complexity_of_variables</code>: What complexity should be assigned to use of a variable,   which can also be a vector indicating different per-variable complexity.   By default, this is 1.</p></li><li><p><code>complexity_mapping</code>: Alternatively, you can pass a function that takes   the expression as input and returns the complexity. Make sure that   this operates on <code>AbstractExpression</code> (and unpacks to <code>AbstractExpressionNode</code>),   and returns an integer.</p></li><li><p><code>alpha</code>: The probability of accepting an equation mutation   during regularized evolution is given by exp(-delta_loss/(alpha * T)),   where T goes from 1 to 0. Thus, alpha=infinite is the same as no annealing.</p></li><li><p><code>maxsize</code>: Maximum size of equations during the search.</p></li><li><p><code>maxdepth</code>: Maximum depth of equations during the search, by default   this is set equal to the maxsize.</p></li><li><p><code>parsimony</code>: A multiplicative factor for how much complexity is   punished.</p></li><li><p><code>dimensional_constraint_penalty</code>: An additive factor if the dimensional   constraint is violated.</p></li><li><p><code>dimensionless_constants_only</code>: Whether to only allow dimensionless   constants.</p></li><li><p><code>use_frequency</code>: Whether to use a parsimony that adapts to the   relative proportion of equations at each complexity; this will   ensure that there are a balanced number of equations considered   for every complexity.</p></li><li><p><code>use_frequency_in_tournament</code>: Whether to use the adaptive parsimony described   above inside the score, rather than just at the mutation accept/reject stage.</p></li><li><p><code>adaptive_parsimony_scaling</code>: How much to scale the adaptive parsimony term   in the loss. Increase this if the search is spending too much time   optimizing the most complex equations.</p></li><li><p><code>turbo</code>: Whether to use <code>LoopVectorization.@turbo</code> to evaluate expressions.   This can be significantly faster, but is only compatible with certain   operators. <em>Experimental!</em></p></li><li><p><code>bumper</code>: Whether to use Bumper.jl for faster evaluation. <em>Experimental!</em></p></li><li><p><code>migration</code>: Whether to migrate equations between processes.</p></li><li><p><code>hof_migration</code>: Whether to migrate equations from the hall of fame   to processes.</p></li><li><p><code>fraction_replaced</code>: What fraction of each population to replace with   migrated equations at the end of each cycle.</p></li><li><p><code>fraction_replaced_hof</code>: What fraction to replace with hall of fame   equations at the end of each cycle.</p></li><li><p><code>should_simplify</code>: Whether to simplify equations. If you   pass a custom objective, this will be set to <code>false</code>.</p></li><li><p><code>should_optimize_constants</code>: Whether to use an optimization algorithm   to periodically optimize constants in equations.</p></li><li><p><code>optimizer_algorithm</code>: Select algorithm to use for optimizing constants. Default   is <code>Optim.BFGS(linesearch=LineSearches.BackTracking())</code>.</p></li><li><p><code>optimizer_nrestarts</code>: How many different random starting positions to consider   for optimization of constants.</p></li><li><p><code>optimizer_probability</code>: Probability of performing optimization of constants at   the end of a given iteration.</p></li><li><p><code>optimizer_iterations</code>: How many optimization iterations to perform. This gets   passed to <code>Optim.Options</code> as <code>iterations</code>. The default is 8.</p></li><li><p><code>optimizer_f_calls_limit</code>: How many function calls to allow during optimization.   This gets passed to <code>Optim.Options</code> as <code>f_calls_limit</code>. The default is   <code>10_000</code>.</p></li><li><p><code>optimizer_options</code>: General options for the constant optimization. For details   we refer to the documentation on <code>Optim.Options</code> from the <code>Optim.jl</code> package.   Options can be provided here as <code>NamedTuple</code>, e.g. <code>(iterations=16,)</code>, as a   <code>Dict</code>, e.g. Dict(:x_tol =&gt; 1.0e-32,), or as an <code>Optim.Options</code> instance.</p></li><li><p><code>autodiff_backend</code>: The backend to use for differentiation, which should be   an instance of <code>AbstractADType</code> (see <code>ADTypes.jl</code>).   Default is <code>nothing</code>, which means <code>Optim.jl</code> will estimate gradients (likely   with finite differences). You can also pass a symbolic version of the backend   type, such as <code>:Zygote</code> for Zygote, <code>:Enzyme</code>, etc. Most backends will not   work, and many will never work due to incompatibilities, though support for some   is gradually being added.</p></li><li><p><code>perturbation_factor</code>: When mutating a constant, either   multiply or divide by (1+perturbation_factor)^(rand()+1).</p></li><li><p><code>probability_negate_constant</code>: Probability of negating a constant in the equation   when mutating it.</p></li><li><p><code>mutation_weights</code>: Relative probabilities of the mutations. The struct   <code>MutationWeights</code> (or any <code>AbstractMutationWeights</code>) should be passed to these options.   See its documentation on <code>MutationWeights</code> for the different weights.</p></li><li><p><code>crossover_probability</code>: Probability of performing crossover.</p></li><li><p><code>annealing</code>: Whether to use simulated annealing.</p></li><li><p><code>warmup_maxsize_by</code>: Whether to slowly increase the max size from 5 up to   <code>maxsize</code>. If nonzero, specifies the fraction through the search   at which the maxsize should be reached.</p></li><li><p><code>verbosity</code>: Whether to print debugging statements or   not.</p></li><li><p><code>print_precision</code>: How many digits to print when printing   equations. By default, this is 5.</p></li><li><p><code>output_directory</code>: The base directory to save output files to. Files   will be saved in a subdirectory according to the run ID. By default,   this is <code>./outputs</code>.</p></li><li><p><code>save_to_file</code>: Whether to save equations to a file during the search.</p></li><li><p><code>bin_constraints</code>: See <code>constraints</code>. This is the same, but specified for binary   operators only (for example, if you have an operator that is both a binary   and unary operator).</p></li><li><p><code>una_constraints</code>: Likewise, for unary operators.</p></li><li><p><code>seed</code>: What random seed to use. <code>nothing</code> uses no seed.</p></li><li><p><code>progress</code>: Whether to use a progress bar output (<code>verbosity</code> will   have no effect).</p></li><li><p><code>early_stop_condition</code>: Float - whether to stop early if the mean loss gets below this value.   Function - a function taking (loss, complexity) as arguments and returning true or false.</p></li><li><p><code>timeout_in_seconds</code>: Float64 - the time in seconds after which to exit (as an alternative to the number of iterations).</p></li><li><p><code>max_evals</code>: Int (or Nothing) - the maximum number of evaluations of expressions to perform.</p></li><li><p><code>input_stream</code>: the stream to read user input from. By default, this is <code>stdin</code>. If you encounter issues   with reading from <code>stdin</code>, like a hang, you can simply pass <code>devnull</code> to this argument.</p></li><li><p><code>skip_mutation_failures</code>: Whether to simply skip over mutations that fail or are rejected, rather than to replace the mutated   expression with the original expression and proceed normally.</p></li><li><p><code>nested_constraints</code>: Specifies how many times a combination of operators can be nested. For example,   <code>[sin =&gt; [cos =&gt; 0], cos =&gt; [cos =&gt; 2]]</code> specifies that <code>cos</code> may never appear within a <code>sin</code>,   but <code>sin</code> can be nested with itself an unlimited number of times. The second term specifies that <code>cos</code>   can be nested up to 2 times within a <code>cos</code>, so that <code>cos(cos(cos(x)))</code> is allowed (as well as any combination   of <code>+</code> or <code>-</code> within it), but <code>cos(cos(cos(cos(x))))</code> is not allowed. When an operator is not specified,   it is assumed that it can be nested an unlimited number of times. This requires that there is no operator   which is used both in the unary operators and the binary operators (e.g., <code>-</code> could be both subtract, and negation).   For binary operators, both arguments are treated the same way, and the max of each argument is constrained.</p></li><li><p><code>deterministic</code>: Use a global counter for the birth time, rather than calls to <code>time()</code>. This gives   perfect resolution, and is therefore deterministic. However, it is not thread safe, and must be used   in serial mode.</p></li><li><p><code>define_helper_functions</code>: Whether to define helper functions   for constructing and evaluating trees.</p></li><li><p><code>niterations::Int=10</code>: The number of iterations to perform the search.   More iterations will improve the results.</p></li><li><p><code>parallelism=:multithreading</code>: What parallelism mode to use.   The options are <code>:multithreading</code>, <code>:multiprocessing</code>, and <code>:serial</code>.   By default, multithreading will be used. Multithreading uses less memory,   but multiprocessing can handle multi-node compute. If using <code>:multithreading</code>   mode, the number of threads available to julia are used. If using   <code>:multiprocessing</code>, <code>numprocs</code> processes will be created dynamically if   <code>procs</code> is unset. If you have already allocated processes, pass them   to the <code>procs</code> argument and they will be used.   You may also pass a string instead of a symbol, like <code>&quot;multithreading&quot;</code>.</p></li><li><p><code>numprocs::Union{Int, Nothing}=nothing</code>:  The number of processes to use,   if you want <code>equation_search</code> to set this up automatically. By default   this will be <code>4</code>, but can be any number (you should pick a number &lt;=   the number of cores available).</p></li><li><p><code>procs::Union{Vector{Int}, Nothing}=nothing</code>: If you have set up   a distributed run manually with <code>procs = addprocs()</code> and <code>@everywhere</code>,   pass the <code>procs</code> to this keyword argument.</p></li><li><p><code>addprocs_function::Union{Function, Nothing}=nothing</code>: If using multiprocessing   (<code>parallelism=:multithreading</code>), and are not passing <code>procs</code> manually,   then they will be allocated dynamically using <code>addprocs</code>. However,   you may also pass a custom function to use instead of <code>addprocs</code>.   This function should take a single positional argument,   which is the number of processes to use, as well as the <code>lazy</code> keyword argument.   For example, if set up on a slurm cluster, you could pass   <code>addprocs_function = addprocs_slurm</code>, which will set up slurm processes.</p></li><li><p><code>heap_size_hint_in_bytes::Union{Int,Nothing}=nothing</code>: On Julia 1.9+, you may set the <code>--heap-size-hint</code>   flag on Julia processes, recommending garbage collection once a process   is close to the recommended size. This is important for long-running distributed   jobs where each process has an independent memory, and can help avoid   out-of-memory errors. By default, this is set to <code>Sys.free_memory() / numprocs</code>.</p></li><li><p><code>worker_imports::Union{Vector{Symbol},Nothing}=nothing</code>: If you want to import   additional modules on each worker, pass them here as a vector of symbols.   By default some of the extensions will automatically be loaded when needed.</p></li><li><p><code>runtests::Bool=true</code>: Whether to run (quick) tests before starting the   search, to see if there will be any problems during the equation search   related to the host environment.</p></li><li><p><code>run_id::Union{String,Nothing}=nothing</code>: A unique identifier for the run.   This will be used to store outputs from the run in the <code>outputs</code> directory.   If not specified, a unique ID will be generated.</p></li><li><p><code>loss_type::Type=Nothing</code>: If you would like to use a different type   for the loss than for the data you passed, specify the type here.   Note that if you pass complex data <code>::Complex{L}</code>, then the loss   type will automatically be set to <code>L</code>.</p></li><li><p><code>selection_method::Function</code>: Function to selection expression from   the Pareto frontier for use in <code>predict</code>.   See <code>SymbolicRegression.MLJInterfaceModule.choose_best</code> for an example.   This function should return a single integer specifying   the index of the expression to use. By default, this maximizes   the score (a pound-for-pound rating) of expressions reaching the threshold   of 1.5x the minimum loss. To override this at prediction time, you can pass   a named tuple with keys <code>data</code> and <code>idx</code> to <code>predict</code>. See the Operations   section for details.</p></li><li><p><code>dimensions_type::AbstractDimensions</code>: The type of dimensions to use when storing   the units of the data. By default this is <code>DynamicQuantities.SymbolicDimensions</code>.</p></li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: Return predictions of the target given features <code>Xnew</code>, which   should have same scitype as <code>X</code> above. The expression used for prediction is defined   by the <code>selection_method</code> function, which can be seen by viewing <code>report(mach).best_idx</code>.</li><li><code>predict(mach, (data=Xnew, idx=i))</code>: Return predictions of the target given features   <code>Xnew</code>, which should have same scitype as <code>X</code> above. By passing a named tuple with keys   <code>data</code> and <code>idx</code>, you are able to specify the equation you wish to evaluate in <code>idx</code>.</li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>best_idx::Int</code>: The index of the best expression in the Pareto frontier,  as determined by the <code>selection_method</code> function. Override in <code>predict</code> by passing   a named tuple with keys <code>data</code> and <code>idx</code>.</li><li><code>equations::Vector{Node{T}}</code>: The expressions discovered by the search, represented in a dominating Pareto frontier (i.e., the best expressions found for each complexity). <code>T</code> is equal to the element type of the passed data.</li><li><code>equation_strings::Vector{String}</code>: The expressions discovered by the search, represented as strings for easy inspection.</li></ul><p><strong>Report</strong></p><p>The fields of <code>report(mach)</code> are:</p><ul><li><code>best_idx::Int</code>: The index of the best expression in the Pareto frontier,  as determined by the <code>selection_method</code> function. Override in <code>predict</code> by passing  a named tuple with keys <code>data</code> and <code>idx</code>.</li><li><code>equations::Vector{Node{T}}</code>: The expressions discovered by the search, represented in a dominating Pareto frontier (i.e., the best expressions found for each complexity).</li><li><code>equation_strings::Vector{String}</code>: The expressions discovered by the search, represented as strings for easy inspection.</li><li><code>complexities::Vector{Int}</code>: The complexity of each expression in the Pareto frontier.</li><li><code>losses::Vector{L}</code>: The loss of each expression in the Pareto frontier, according to the loss function specified in the model. The type <code>L</code> is the loss type, which is usually the same as the element type of data passed (i.e., <code>T</code>), but can differ if complex data types are passed.</li><li><code>scores::Vector{L}</code>: A metric which considers both the complexity and loss of an expression, equal to the change in the log-loss divided by the change in complexity, relative to the previous expression along the Pareto frontier. A larger score aims to indicate an expression is more likely to be the true expression generating the data, but this is very problem-dependent and generally several other factors should be considered.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MLJ
SRRegressor = @load SRRegressor pkg=SymbolicRegression
X, y = @load_boston
model = SRRegressor(binary_operators=[+, -, *], unary_operators=[exp], niterations=100)
mach = machine(model, X, y)
fit!(mach)
y_hat = predict(mach, X)
# View the equation used:
r = report(mach)
println(&quot;Equation used:&quot;, r.equation_strings[r.best_idx])</code></pre><p>With units and variable names:</p><pre><code class="language-julia hljs">using MLJ
using DynamicQuantities
SRegressor = @load SRRegressor pkg=SymbolicRegression

X = (; x1=rand(32) .* us&quot;km/h&quot;, x2=rand(32) .* us&quot;km&quot;)
y = @. X.x2 / X.x1 + 0.5us&quot;h&quot;
model = SRRegressor(binary_operators=[+, -, *, /])
mach = machine(model, X, y)
fit!(mach)
y_hat = predict(mach, X)
# View the equation used:
r = report(mach)
println(&quot;Equation used:&quot;, r.equation_strings[r.best_idx])</code></pre><p>See also <a href="#SymbolicRegression.MLJInterfaceModule.MultitargetSRRegressor"><code>MultitargetSRRegressor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/MLJInterface.jl#L748-L1150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.MLJInterfaceModule.MultitargetSRRegressor" href="#SymbolicRegression.MLJInterfaceModule.MultitargetSRRegressor"><code>SymbolicRegression.MLJInterfaceModule.MultitargetSRRegressor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultitargetSRRegressor</code></pre><p>A model type for constructing a Multi-Target Symbolic Regression via Evolutionary Search, based on <a href="https://github.com/MilesCranmer/SymbolicRegression.jl">SymbolicRegression.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">MultitargetSRRegressor = @load MultitargetSRRegressor pkg=SymbolicRegression</code></pre><p>Do <code>model = MultitargetSRRegressor()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>MultitargetSRRegressor(defaults=...)</code>.</p><p>Multi-target Symbolic Regression regressor (<code>MultitargetSRRegressor</code>) conducts several searches for expressions that predict each target variable from a set of input variables. All data is assumed to be <code>Continuous</code>. The search is performed using an evolutionary algorithm. This algorithm is described in the paper https://arxiv.org/abs/2305.01582.</p><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with</p><pre><code class="nohighlight hljs">mach = machine(model, X, y)</code></pre><p>OR</p><pre><code class="nohighlight hljs">mach = machine(model, X, y, w)</code></pre><p>Here:</p><ul><li><code>X</code> is any table of input features (eg, a <code>DataFrame</code>) whose columns are of scitype</li></ul><p><code>Continuous</code>; check column scitypes with <code>schema(X)</code>. Variable names in discovered expressions will be taken from the column names of <code>X</code>, if available. Units in columns of <code>X</code> (use <code>DynamicQuantities</code> for units) will trigger dimensional analysis to be used.</p><ul><li><p><code>y</code> is the target, which can be any table of target variables whose element scitype is <code>Continuous</code>; check the scitype with <code>schema(y)</code>. Units in columns of <code>y</code> (use <code>DynamicQuantities</code> for units) will trigger dimensional analysis to be used.</p></li><li><p><code>w</code> is the observation weights which can either be <code>nothing</code> (default) or an <code>AbstractVector</code> whose element scitype is <code>Count</code> or <code>Continuous</code>. The same weights are used for all targets.</p></li></ul><p>Train the machine using <code>fit!(mach)</code>, inspect the discovered expressions with <code>report(mach)</code>, and predict on new data with <code>predict(mach, Xnew)</code>. Note that unlike other regressors, symbolic regression stores a list of lists of trained models. The models chosen from each of these lists is defined by the function <code>selection_method</code> keyword argument, which by default balances accuracy and complexity. You can override this at prediction time by passing a named tuple with keys <code>data</code> and <code>idx</code>.</p><p><strong>Hyper-parameters</strong></p><ul><li><p><code>defaults</code>: What set of defaults to use for <code>Options</code>. The default,   <code>nothing</code>, will simply take the default options from the current version of SymbolicRegression.   However, you may also select the defaults from an earlier version, such as <code>v&quot;0.24.5&quot;</code>.</p></li><li><p><code>binary_operators</code>: Vector of binary operators (functions) to use.   Each operator should be defined for two input scalars,   and one output scalar. All operators   need to be defined over the entire real line (excluding infinity - these   are stopped before they are input), or return <code>NaN</code> where not defined.   For speed, define it so it takes two reals   of the same type as input, and outputs the same type. For the SymbolicUtils   simplification backend, you will need to define a generic method of the   operator so it takes arbitrary types.</p></li><li><p><code>unary_operators</code>: Same, but for   unary operators (one input scalar, gives an output scalar).</p></li><li><p><code>constraints</code>: Array of pairs specifying size constraints   for each operator. The constraints for a binary operator should be a 2-tuple   (e.g., <code>(-1, -1)</code>) and the constraints for a unary operator should be an <code>Int</code>.   A size constraint is a limit to the size of the subtree   in each argument of an operator. e.g., <code>[(^)=&gt;(-1, 3)]</code> means that the   <code>^</code> operator can have arbitrary size (<code>-1</code>) in its left argument,   but a maximum size of <code>3</code> in its right argument. Default is   no constraints.</p></li><li><p><code>batching</code>: Whether to evolve based on small mini-batches of data,   rather than the entire dataset.</p></li><li><p><code>batch_size</code>: What batch size to use if using batching.</p></li><li><p><code>elementwise_loss</code>: What elementwise loss function to use. Can be one of   the following losses, or any other loss of type   <code>SupervisedLoss</code>. You can also pass a function that takes   a scalar target (left argument), and scalar predicted (right   argument), and returns a scalar. This will be averaged   over the predicted data. If weights are supplied, your   function should take a third argument for the weight scalar.   Included losses:       Regression:           - <code>LPDistLoss{P}()</code>,           - <code>L1DistLoss()</code>,           - <code>L2DistLoss()</code> (mean square),           - <code>LogitDistLoss()</code>,           - <code>HuberLoss(d)</code>,           - <code>L1EpsilonInsLoss(ϵ)</code>,           - <code>L2EpsilonInsLoss(ϵ)</code>,           - <code>PeriodicLoss(c)</code>,           - <code>QuantileLoss(τ)</code>,       Classification:           - <code>ZeroOneLoss()</code>,           - <code>PerceptronLoss()</code>,           - <code>L1HingeLoss()</code>,           - <code>SmoothedL1HingeLoss(γ)</code>,           - <code>ModifiedHuberLoss()</code>,           - <code>L2MarginLoss()</code>,           - <code>ExpLoss()</code>,           - <code>SigmoidLoss()</code>,           - <code>DWDMarginLoss(q)</code>.</p></li><li><p><code>loss_function</code>: Alternatively, you may redefine the loss used   as any function of <code>tree::AbstractExpressionNode{T}</code>, <code>dataset::Dataset{T}</code>,   and <code>options::AbstractOptions</code>, so long as you output a non-negative   scalar of type <code>T</code>. This is useful if you want to use a loss   that takes into account derivatives, or correlations across   the dataset. This also means you could use a custom evaluation   for a particular expression. If you are using   <code>batching=true</code>, then your function should   accept a fourth argument <code>idx</code>, which is either <code>nothing</code>   (indicating that the full dataset should be used), or a vector   of indices to use for the batch.   For example,</p><pre><code class="nohighlight hljs">  function my_loss(tree, dataset::Dataset{T,L}, options)::L where {T,L}
      prediction, flag = eval_tree_array(tree, dataset.X, options)
      if !flag
          return L(Inf)
      end
      return sum((prediction .- dataset.y) .^ 2) / dataset.n
  end</code></pre></li><li><p><code>expression_type::Type{E}=Expression</code>: The type of expression to use.   For example, <code>Expression</code>.</p></li><li><p><code>node_type::Type{N}=default_node_type(Expression)</code>: The type of node to use for the search.   For example, <code>Node</code> or <code>GraphNode</code>. The default is computed by <code>default_node_type(expression_type)</code>.</p></li><li><p><code>populations</code>: How many populations of equations to use.</p></li><li><p><code>population_size</code>: How many equations in each population.</p></li><li><p><code>ncycles_per_iteration</code>: How many generations to consider per iteration.</p></li><li><p><code>tournament_selection_n</code>: Number of expressions considered in each tournament.</p></li><li><p><code>tournament_selection_p</code>: The fittest expression in a tournament is to be   selected with probability <code>p</code>, the next fittest with probability <code>p*(1-p)</code>,   and so forth.</p></li><li><p><code>topn</code>: Number of equations to return to the host process, and to   consider for the hall of fame.</p></li><li><p><code>complexity_of_operators</code>: What complexity should be assigned to each operator,   and the occurrence of a constant or variable. By default, this is 1   for all operators. Can be a real number as well, in which case   the complexity of an expression will be rounded to the nearest integer.   Input this in the form of, e.g., [(^) =&gt; 3, sin =&gt; 2].</p></li><li><p><code>complexity_of_constants</code>: What complexity should be assigned to use of a constant.   By default, this is 1.</p></li><li><p><code>complexity_of_variables</code>: What complexity should be assigned to use of a variable,   which can also be a vector indicating different per-variable complexity.   By default, this is 1.</p></li><li><p><code>complexity_mapping</code>: Alternatively, you can pass a function that takes   the expression as input and returns the complexity. Make sure that   this operates on <code>AbstractExpression</code> (and unpacks to <code>AbstractExpressionNode</code>),   and returns an integer.</p></li><li><p><code>alpha</code>: The probability of accepting an equation mutation   during regularized evolution is given by exp(-delta_loss/(alpha * T)),   where T goes from 1 to 0. Thus, alpha=infinite is the same as no annealing.</p></li><li><p><code>maxsize</code>: Maximum size of equations during the search.</p></li><li><p><code>maxdepth</code>: Maximum depth of equations during the search, by default   this is set equal to the maxsize.</p></li><li><p><code>parsimony</code>: A multiplicative factor for how much complexity is   punished.</p></li><li><p><code>dimensional_constraint_penalty</code>: An additive factor if the dimensional   constraint is violated.</p></li><li><p><code>dimensionless_constants_only</code>: Whether to only allow dimensionless   constants.</p></li><li><p><code>use_frequency</code>: Whether to use a parsimony that adapts to the   relative proportion of equations at each complexity; this will   ensure that there are a balanced number of equations considered   for every complexity.</p></li><li><p><code>use_frequency_in_tournament</code>: Whether to use the adaptive parsimony described   above inside the score, rather than just at the mutation accept/reject stage.</p></li><li><p><code>adaptive_parsimony_scaling</code>: How much to scale the adaptive parsimony term   in the loss. Increase this if the search is spending too much time   optimizing the most complex equations.</p></li><li><p><code>turbo</code>: Whether to use <code>LoopVectorization.@turbo</code> to evaluate expressions.   This can be significantly faster, but is only compatible with certain   operators. <em>Experimental!</em></p></li><li><p><code>bumper</code>: Whether to use Bumper.jl for faster evaluation. <em>Experimental!</em></p></li><li><p><code>migration</code>: Whether to migrate equations between processes.</p></li><li><p><code>hof_migration</code>: Whether to migrate equations from the hall of fame   to processes.</p></li><li><p><code>fraction_replaced</code>: What fraction of each population to replace with   migrated equations at the end of each cycle.</p></li><li><p><code>fraction_replaced_hof</code>: What fraction to replace with hall of fame   equations at the end of each cycle.</p></li><li><p><code>should_simplify</code>: Whether to simplify equations. If you   pass a custom objective, this will be set to <code>false</code>.</p></li><li><p><code>should_optimize_constants</code>: Whether to use an optimization algorithm   to periodically optimize constants in equations.</p></li><li><p><code>optimizer_algorithm</code>: Select algorithm to use for optimizing constants. Default   is <code>Optim.BFGS(linesearch=LineSearches.BackTracking())</code>.</p></li><li><p><code>optimizer_nrestarts</code>: How many different random starting positions to consider   for optimization of constants.</p></li><li><p><code>optimizer_probability</code>: Probability of performing optimization of constants at   the end of a given iteration.</p></li><li><p><code>optimizer_iterations</code>: How many optimization iterations to perform. This gets   passed to <code>Optim.Options</code> as <code>iterations</code>. The default is 8.</p></li><li><p><code>optimizer_f_calls_limit</code>: How many function calls to allow during optimization.   This gets passed to <code>Optim.Options</code> as <code>f_calls_limit</code>. The default is   <code>10_000</code>.</p></li><li><p><code>optimizer_options</code>: General options for the constant optimization. For details   we refer to the documentation on <code>Optim.Options</code> from the <code>Optim.jl</code> package.   Options can be provided here as <code>NamedTuple</code>, e.g. <code>(iterations=16,)</code>, as a   <code>Dict</code>, e.g. Dict(:x_tol =&gt; 1.0e-32,), or as an <code>Optim.Options</code> instance.</p></li><li><p><code>autodiff_backend</code>: The backend to use for differentiation, which should be   an instance of <code>AbstractADType</code> (see <code>ADTypes.jl</code>).   Default is <code>nothing</code>, which means <code>Optim.jl</code> will estimate gradients (likely   with finite differences). You can also pass a symbolic version of the backend   type, such as <code>:Zygote</code> for Zygote, <code>:Enzyme</code>, etc. Most backends will not   work, and many will never work due to incompatibilities, though support for some   is gradually being added.</p></li><li><p><code>perturbation_factor</code>: When mutating a constant, either   multiply or divide by (1+perturbation_factor)^(rand()+1).</p></li><li><p><code>probability_negate_constant</code>: Probability of negating a constant in the equation   when mutating it.</p></li><li><p><code>mutation_weights</code>: Relative probabilities of the mutations. The struct   <code>MutationWeights</code> (or any <code>AbstractMutationWeights</code>) should be passed to these options.   See its documentation on <code>MutationWeights</code> for the different weights.</p></li><li><p><code>crossover_probability</code>: Probability of performing crossover.</p></li><li><p><code>annealing</code>: Whether to use simulated annealing.</p></li><li><p><code>warmup_maxsize_by</code>: Whether to slowly increase the max size from 5 up to   <code>maxsize</code>. If nonzero, specifies the fraction through the search   at which the maxsize should be reached.</p></li><li><p><code>verbosity</code>: Whether to print debugging statements or   not.</p></li><li><p><code>print_precision</code>: How many digits to print when printing   equations. By default, this is 5.</p></li><li><p><code>output_directory</code>: The base directory to save output files to. Files   will be saved in a subdirectory according to the run ID. By default,   this is <code>./outputs</code>.</p></li><li><p><code>save_to_file</code>: Whether to save equations to a file during the search.</p></li><li><p><code>bin_constraints</code>: See <code>constraints</code>. This is the same, but specified for binary   operators only (for example, if you have an operator that is both a binary   and unary operator).</p></li><li><p><code>una_constraints</code>: Likewise, for unary operators.</p></li><li><p><code>seed</code>: What random seed to use. <code>nothing</code> uses no seed.</p></li><li><p><code>progress</code>: Whether to use a progress bar output (<code>verbosity</code> will   have no effect).</p></li><li><p><code>early_stop_condition</code>: Float - whether to stop early if the mean loss gets below this value.   Function - a function taking (loss, complexity) as arguments and returning true or false.</p></li><li><p><code>timeout_in_seconds</code>: Float64 - the time in seconds after which to exit (as an alternative to the number of iterations).</p></li><li><p><code>max_evals</code>: Int (or Nothing) - the maximum number of evaluations of expressions to perform.</p></li><li><p><code>input_stream</code>: the stream to read user input from. By default, this is <code>stdin</code>. If you encounter issues   with reading from <code>stdin</code>, like a hang, you can simply pass <code>devnull</code> to this argument.</p></li><li><p><code>skip_mutation_failures</code>: Whether to simply skip over mutations that fail or are rejected, rather than to replace the mutated   expression with the original expression and proceed normally.</p></li><li><p><code>nested_constraints</code>: Specifies how many times a combination of operators can be nested. For example,   <code>[sin =&gt; [cos =&gt; 0], cos =&gt; [cos =&gt; 2]]</code> specifies that <code>cos</code> may never appear within a <code>sin</code>,   but <code>sin</code> can be nested with itself an unlimited number of times. The second term specifies that <code>cos</code>   can be nested up to 2 times within a <code>cos</code>, so that <code>cos(cos(cos(x)))</code> is allowed (as well as any combination   of <code>+</code> or <code>-</code> within it), but <code>cos(cos(cos(cos(x))))</code> is not allowed. When an operator is not specified,   it is assumed that it can be nested an unlimited number of times. This requires that there is no operator   which is used both in the unary operators and the binary operators (e.g., <code>-</code> could be both subtract, and negation).   For binary operators, both arguments are treated the same way, and the max of each argument is constrained.</p></li><li><p><code>deterministic</code>: Use a global counter for the birth time, rather than calls to <code>time()</code>. This gives   perfect resolution, and is therefore deterministic. However, it is not thread safe, and must be used   in serial mode.</p></li><li><p><code>define_helper_functions</code>: Whether to define helper functions   for constructing and evaluating trees.</p></li><li><p><code>niterations::Int=10</code>: The number of iterations to perform the search.   More iterations will improve the results.</p></li><li><p><code>parallelism=:multithreading</code>: What parallelism mode to use.   The options are <code>:multithreading</code>, <code>:multiprocessing</code>, and <code>:serial</code>.   By default, multithreading will be used. Multithreading uses less memory,   but multiprocessing can handle multi-node compute. If using <code>:multithreading</code>   mode, the number of threads available to julia are used. If using   <code>:multiprocessing</code>, <code>numprocs</code> processes will be created dynamically if   <code>procs</code> is unset. If you have already allocated processes, pass them   to the <code>procs</code> argument and they will be used.   You may also pass a string instead of a symbol, like <code>&quot;multithreading&quot;</code>.</p></li><li><p><code>numprocs::Union{Int, Nothing}=nothing</code>:  The number of processes to use,   if you want <code>equation_search</code> to set this up automatically. By default   this will be <code>4</code>, but can be any number (you should pick a number &lt;=   the number of cores available).</p></li><li><p><code>procs::Union{Vector{Int}, Nothing}=nothing</code>: If you have set up   a distributed run manually with <code>procs = addprocs()</code> and <code>@everywhere</code>,   pass the <code>procs</code> to this keyword argument.</p></li><li><p><code>addprocs_function::Union{Function, Nothing}=nothing</code>: If using multiprocessing   (<code>parallelism=:multithreading</code>), and are not passing <code>procs</code> manually,   then they will be allocated dynamically using <code>addprocs</code>. However,   you may also pass a custom function to use instead of <code>addprocs</code>.   This function should take a single positional argument,   which is the number of processes to use, as well as the <code>lazy</code> keyword argument.   For example, if set up on a slurm cluster, you could pass   <code>addprocs_function = addprocs_slurm</code>, which will set up slurm processes.</p></li><li><p><code>heap_size_hint_in_bytes::Union{Int,Nothing}=nothing</code>: On Julia 1.9+, you may set the <code>--heap-size-hint</code>   flag on Julia processes, recommending garbage collection once a process   is close to the recommended size. This is important for long-running distributed   jobs where each process has an independent memory, and can help avoid   out-of-memory errors. By default, this is set to <code>Sys.free_memory() / numprocs</code>.</p></li><li><p><code>worker_imports::Union{Vector{Symbol},Nothing}=nothing</code>: If you want to import   additional modules on each worker, pass them here as a vector of symbols.   By default some of the extensions will automatically be loaded when needed.</p></li><li><p><code>runtests::Bool=true</code>: Whether to run (quick) tests before starting the   search, to see if there will be any problems during the equation search   related to the host environment.</p></li><li><p><code>run_id::Union{String,Nothing}=nothing</code>: A unique identifier for the run.   This will be used to store outputs from the run in the <code>outputs</code> directory.   If not specified, a unique ID will be generated.</p></li><li><p><code>loss_type::Type=Nothing</code>: If you would like to use a different type   for the loss than for the data you passed, specify the type here.   Note that if you pass complex data <code>::Complex{L}</code>, then the loss   type will automatically be set to <code>L</code>.</p></li><li><p><code>selection_method::Function</code>: Function to selection expression from   the Pareto frontier for use in <code>predict</code>.   See <code>SymbolicRegression.MLJInterfaceModule.choose_best</code> for an example.   This function should return a single integer specifying   the index of the expression to use. By default, this maximizes   the score (a pound-for-pound rating) of expressions reaching the threshold   of 1.5x the minimum loss. To override this at prediction time, you can pass   a named tuple with keys <code>data</code> and <code>idx</code> to <code>predict</code>. See the Operations   section for details.</p></li><li><p><code>dimensions_type::AbstractDimensions</code>: The type of dimensions to use when storing   the units of the data. By default this is <code>DynamicQuantities.SymbolicDimensions</code>.</p></li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: Return predictions of the target given features <code>Xnew</code>, which   should have same scitype as <code>X</code> above. The expression used for prediction is defined   by the <code>selection_method</code> function, which can be seen by viewing <code>report(mach).best_idx</code>.</li><li><code>predict(mach, (data=Xnew, idx=i))</code>: Return predictions of the target given features   <code>Xnew</code>, which should have same scitype as <code>X</code> above. By passing a named tuple with keys   <code>data</code> and <code>idx</code>, you are able to specify the equation you wish to evaluate in <code>idx</code>.</li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>best_idx::Vector{Int}</code>: The index of the best expression in each Pareto frontier, as determined by the <code>selection_method</code> function. Override in <code>predict</code> by passing a named tuple with keys <code>data</code> and <code>idx</code>.</li><li><code>equations::Vector{Vector{Node{T}}}</code>: The expressions discovered by the search, represented in a dominating Pareto frontier (i.e., the best expressions found for each complexity). The outer vector is indexed by target variable, and the inner vector is ordered by increasing complexity. <code>T</code> is equal to the element type of the passed data.</li><li><code>equation_strings::Vector{Vector{String}}</code>: The expressions discovered by the search, represented as strings for easy inspection.</li></ul><p><strong>Report</strong></p><p>The fields of <code>report(mach)</code> are:</p><ul><li><code>best_idx::Vector{Int}</code>: The index of the best expression in each Pareto frontier,  as determined by the <code>selection_method</code> function. Override in <code>predict</code> by passing  a named tuple with keys <code>data</code> and <code>idx</code>.</li><li><code>equations::Vector{Vector{Node{T}}}</code>: The expressions discovered by the search, represented in a dominating Pareto frontier (i.e., the best expressions found for each complexity). The outer vector is indexed by target variable, and the inner vector is ordered by increasing complexity.</li><li><code>equation_strings::Vector{Vector{String}}</code>: The expressions discovered by the search, represented as strings for easy inspection.</li><li><code>complexities::Vector{Vector{Int}}</code>: The complexity of each expression in each Pareto frontier.</li><li><code>losses::Vector{Vector{L}}</code>: The loss of each expression in each Pareto frontier, according to the loss function specified in the model. The type <code>L</code> is the loss type, which is usually the same as the element type of data passed (i.e., <code>T</code>), but can differ if complex data types are passed.</li><li><code>scores::Vector{Vector{L}}</code>: A metric which considers both the complexity and loss of an expression, equal to the change in the log-loss divided by the change in complexity, relative to the previous expression along the Pareto frontier. A larger score aims to indicate an expression is more likely to be the true expression generating the data, but this is very problem-dependent and generally several other factors should be considered.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MLJ
MultitargetSRRegressor = @load MultitargetSRRegressor pkg=SymbolicRegression
X = (a=rand(100), b=rand(100), c=rand(100))
Y = (y1=(@. cos(X.c) * 2.1 - 0.9), y2=(@. X.a * X.b + X.c))
model = MultitargetSRRegressor(binary_operators=[+, -, *], unary_operators=[exp], niterations=100)
mach = machine(model, X, Y)
fit!(mach)
y_hat = predict(mach, X)
# View the equations used:
r = report(mach)
for (output_index, (eq, i)) in enumerate(zip(r.equation_strings, r.best_idx))
    println(&quot;Equation used for &quot;, output_index, &quot;: &quot;, eq[i])
end</code></pre><p>See also <a href="#SymbolicRegression.MLJInterfaceModule.SRRegressor"><code>SRRegressor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/MLJInterface.jl#L748-L1137">source</a></section></article><h2 id="Low-Level-API"><a class="docs-heading-anchor" href="#Low-Level-API">Low-Level API</a><a id="Low-Level-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-Level-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.equation_search" href="#SymbolicRegression.equation_search"><code>SymbolicRegression.equation_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">equation_search(X, y[; kws...])</code></pre><p>Perform a distributed equation search for functions <code>f_i</code> which describe the mapping <code>f_i(X[:, j]) ≈ y[i, j]</code>. Options are configured using SymbolicRegression.Options(...), which should be passed as a keyword argument to options. One can turn off parallelism with <code>numprocs=0</code>, which is useful for debugging and profiling.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix{T}</code>:  The input dataset to predict <code>y</code> from.   The first dimension is features, the second dimension is rows.</li><li><code>y::Union{AbstractMatrix{T}, AbstractVector{T}}</code>: The values to predict. The first dimension   is the output feature to predict with each equation, and the   second dimension is rows.</li><li><code>niterations::Int=100</code>: The number of iterations to perform the search.   More iterations will improve the results.</li><li><code>weights::Union{AbstractMatrix{T}, AbstractVector{T}, Nothing}=nothing</code>: Optionally   weight the loss for each <code>y</code> by this value (same shape as <code>y</code>).</li><li><code>options::AbstractOptions=Options()</code>: The options for the search, such as   which operators to use, evolution hyperparameters, etc.</li><li><code>variable_names::Union{Vector{String}, Nothing}=nothing</code>: The names   of each feature in <code>X</code>, which will be used during printing of equations.</li><li><code>display_variable_names::Union{Vector{String}, Nothing}=variable_names</code>: Names   to use when printing expressions during the search, but not when saving   to an equation file.</li><li><code>y_variable_names::Union{String,AbstractVector{String},Nothing}=nothing</code>: The   names of each output feature in <code>y</code>, which will be used during printing   of equations.</li><li><code>parallelism=:multithreading</code>: What parallelism mode to use.   The options are <code>:multithreading</code>, <code>:multiprocessing</code>, and <code>:serial</code>.   By default, multithreading will be used. Multithreading uses less memory,   but multiprocessing can handle multi-node compute. If using <code>:multithreading</code>   mode, the number of threads available to julia are used. If using   <code>:multiprocessing</code>, <code>numprocs</code> processes will be created dynamically if   <code>procs</code> is unset. If you have already allocated processes, pass them   to the <code>procs</code> argument and they will be used.   You may also pass a string instead of a symbol, like <code>&quot;multithreading&quot;</code>.</li><li><code>numprocs::Union{Int, Nothing}=nothing</code>:  The number of processes to use,   if you want <code>equation_search</code> to set this up automatically. By default   this will be <code>4</code>, but can be any number (you should pick a number &lt;=   the number of cores available).</li><li><code>procs::Union{Vector{Int}, Nothing}=nothing</code>: If you have set up   a distributed run manually with <code>procs = addprocs()</code> and <code>@everywhere</code>,   pass the <code>procs</code> to this keyword argument.</li><li><code>addprocs_function::Union{Function, Nothing}=nothing</code>: If using multiprocessing   (<code>parallelism=:multiprocessing</code>), and are not passing <code>procs</code> manually,   then they will be allocated dynamically using <code>addprocs</code>. However,   you may also pass a custom function to use instead of <code>addprocs</code>.   This function should take a single positional argument,   which is the number of processes to use, as well as the <code>lazy</code> keyword argument.   For example, if set up on a slurm cluster, you could pass   <code>addprocs_function = addprocs_slurm</code>, which will set up slurm processes.</li><li><code>heap_size_hint_in_bytes::Union{Int,Nothing}=nothing</code>: On Julia 1.9+, you may set the <code>--heap-size-hint</code>   flag on Julia processes, recommending garbage collection once a process   is close to the recommended size. This is important for long-running distributed   jobs where each process has an independent memory, and can help avoid   out-of-memory errors. By default, this is set to <code>Sys.free_memory() / numprocs</code>.</li><li><code>worker_imports::Union{Vector{Symbol},Nothing}=nothing</code>: If you want to import   additional modules on each worker, pass them here as a vector of symbols.   By default some of the extensions will automatically be loaded when needed.</li><li><code>runtests::Bool=true</code>: Whether to run (quick) tests before starting the   search, to see if there will be any problems during the equation search   related to the host environment.</li><li><code>saved_state=nothing</code>: If you have already   run <code>equation_search</code> and want to resume it, pass the state here.   To get this to work, you need to have set return<em>state=true,   which will cause `equation</em>search` to return the state. The second   element of the state is the regular return value with the hall of fame.   Note that you cannot change the operators or dataset, but most other options   should be changeable.</li><li><code>return_state::Union{Bool, Nothing}=nothing</code>: Whether to return the   state of the search for warm starts. By default this is false.</li><li><code>loss_type::Type=Nothing</code>: If you would like to use a different type   for the loss than for the data you passed, specify the type here.   Note that if you pass complex data <code>::Complex{L}</code>, then the loss   type will automatically be set to <code>L</code>.</li><li><code>verbosity</code>: Whether to print debugging statements or not.</li><li><code>logger::Union{AbstractSRLogger,Nothing}=nothing</code>: An optional logger to record   the progress of the search. You can use an <code>SRLogger</code> to wrap a custom logger,   or pass <code>nothing</code> to disable logging.</li><li><code>progress</code>: Whether to use a progress bar output. Only available for   single target output.</li><li><code>X_units::Union{AbstractVector,Nothing}=nothing</code>: The units of the dataset,   to be used for dimensional constraints. For example, if <code>X_units=[&quot;kg&quot;, &quot;m&quot;]</code>,   then the first feature will have units of kilograms, and the second will   have units of meters.</li><li><code>y_units=nothing</code>: The units of the output, to be used for dimensional constraints.   If <code>y</code> is a matrix, then this can be a vector of units, in which case   each element corresponds to each output feature.</li></ul><p><strong>Returns</strong></p><ul><li><code>hallOfFame::HallOfFame</code>: The best equations seen during the search.   hallOfFame.members gives an array of <code>PopMember</code> objects, which   have their tree (equation) stored in <code>.tree</code>. Their score (loss)   is given in <code>.score</code>. The array of <code>PopMember</code> objects   is enumerated by size from <code>1</code> to <code>options.maxsize</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/SymbolicRegression.jl#L333-L431">source</a></section></article><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.CoreModule.OptionsStructModule.Options" href="#SymbolicRegression.CoreModule.OptionsStructModule.Options"><code>SymbolicRegression.CoreModule.OptionsStructModule.Options</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Options(;kws...) &lt;: AbstractOptions</code></pre><p>Construct options for <code>equation_search</code> and other functions. The current arguments have been tuned using the median values from https://github.com/MilesCranmer/PySR/discussions/115.</p><p><strong>Arguments</strong></p><ul><li><p><code>defaults</code>: What set of defaults to use for <code>Options</code>. The default,   <code>nothing</code>, will simply take the default options from the current version of SymbolicRegression.   However, you may also select the defaults from an earlier version, such as <code>v&quot;0.24.5&quot;</code>.</p></li><li><p><code>binary_operators</code>: Vector of binary operators (functions) to use.   Each operator should be defined for two input scalars,   and one output scalar. All operators   need to be defined over the entire real line (excluding infinity - these   are stopped before they are input), or return <code>NaN</code> where not defined.   For speed, define it so it takes two reals   of the same type as input, and outputs the same type. For the SymbolicUtils   simplification backend, you will need to define a generic method of the   operator so it takes arbitrary types.</p></li><li><p><code>unary_operators</code>: Same, but for   unary operators (one input scalar, gives an output scalar).</p></li><li><p><code>constraints</code>: Array of pairs specifying size constraints   for each operator. The constraints for a binary operator should be a 2-tuple   (e.g., <code>(-1, -1)</code>) and the constraints for a unary operator should be an <code>Int</code>.   A size constraint is a limit to the size of the subtree   in each argument of an operator. e.g., <code>[(^)=&gt;(-1, 3)]</code> means that the   <code>^</code> operator can have arbitrary size (<code>-1</code>) in its left argument,   but a maximum size of <code>3</code> in its right argument. Default is   no constraints.</p></li><li><p><code>batching</code>: Whether to evolve based on small mini-batches of data,   rather than the entire dataset.</p></li><li><p><code>batch_size</code>: What batch size to use if using batching.</p></li><li><p><code>elementwise_loss</code>: What elementwise loss function to use. Can be one of   the following losses, or any other loss of type   <code>SupervisedLoss</code>. You can also pass a function that takes   a scalar target (left argument), and scalar predicted (right   argument), and returns a scalar. This will be averaged   over the predicted data. If weights are supplied, your   function should take a third argument for the weight scalar.   Included losses:       Regression:           - <code>LPDistLoss{P}()</code>,           - <code>L1DistLoss()</code>,           - <code>L2DistLoss()</code> (mean square),           - <code>LogitDistLoss()</code>,           - <code>HuberLoss(d)</code>,           - <code>L1EpsilonInsLoss(ϵ)</code>,           - <code>L2EpsilonInsLoss(ϵ)</code>,           - <code>PeriodicLoss(c)</code>,           - <code>QuantileLoss(τ)</code>,       Classification:           - <code>ZeroOneLoss()</code>,           - <code>PerceptronLoss()</code>,           - <code>L1HingeLoss()</code>,           - <code>SmoothedL1HingeLoss(γ)</code>,           - <code>ModifiedHuberLoss()</code>,           - <code>L2MarginLoss()</code>,           - <code>ExpLoss()</code>,           - <code>SigmoidLoss()</code>,           - <code>DWDMarginLoss(q)</code>.</p></li><li><p><code>loss_function</code>: Alternatively, you may redefine the loss used   as any function of <code>tree::AbstractExpressionNode{T}</code>, <code>dataset::Dataset{T}</code>,   and <code>options::AbstractOptions</code>, so long as you output a non-negative   scalar of type <code>T</code>. This is useful if you want to use a loss   that takes into account derivatives, or correlations across   the dataset. This also means you could use a custom evaluation   for a particular expression. If you are using   <code>batching=true</code>, then your function should   accept a fourth argument <code>idx</code>, which is either <code>nothing</code>   (indicating that the full dataset should be used), or a vector   of indices to use for the batch.   For example,</p><pre><code class="nohighlight hljs">  function my_loss(tree, dataset::Dataset{T,L}, options)::L where {T,L}
      prediction, flag = eval_tree_array(tree, dataset.X, options)
      if !flag
          return L(Inf)
      end
      return sum((prediction .- dataset.y) .^ 2) / dataset.n
  end</code></pre></li><li><p><code>expression_type::Type{E}=Expression</code>: The type of expression to use.   For example, <code>Expression</code>.</p></li><li><p><code>node_type::Type{N}=default_node_type(Expression)</code>: The type of node to use for the search.   For example, <code>Node</code> or <code>GraphNode</code>. The default is computed by <code>default_node_type(expression_type)</code>.</p></li><li><p><code>populations</code>: How many populations of equations to use.</p></li><li><p><code>population_size</code>: How many equations in each population.</p></li><li><p><code>ncycles_per_iteration</code>: How many generations to consider per iteration.</p></li><li><p><code>tournament_selection_n</code>: Number of expressions considered in each tournament.</p></li><li><p><code>tournament_selection_p</code>: The fittest expression in a tournament is to be   selected with probability <code>p</code>, the next fittest with probability <code>p*(1-p)</code>,   and so forth.</p></li><li><p><code>topn</code>: Number of equations to return to the host process, and to   consider for the hall of fame.</p></li><li><p><code>complexity_of_operators</code>: What complexity should be assigned to each operator,   and the occurrence of a constant or variable. By default, this is 1   for all operators. Can be a real number as well, in which case   the complexity of an expression will be rounded to the nearest integer.   Input this in the form of, e.g., [(^) =&gt; 3, sin =&gt; 2].</p></li><li><p><code>complexity_of_constants</code>: What complexity should be assigned to use of a constant.   By default, this is 1.</p></li><li><p><code>complexity_of_variables</code>: What complexity should be assigned to use of a variable,   which can also be a vector indicating different per-variable complexity.   By default, this is 1.</p></li><li><p><code>complexity_mapping</code>: Alternatively, you can pass a function that takes   the expression as input and returns the complexity. Make sure that   this operates on <code>AbstractExpression</code> (and unpacks to <code>AbstractExpressionNode</code>),   and returns an integer.</p></li><li><p><code>alpha</code>: The probability of accepting an equation mutation   during regularized evolution is given by exp(-delta_loss/(alpha * T)),   where T goes from 1 to 0. Thus, alpha=infinite is the same as no annealing.</p></li><li><p><code>maxsize</code>: Maximum size of equations during the search.</p></li><li><p><code>maxdepth</code>: Maximum depth of equations during the search, by default   this is set equal to the maxsize.</p></li><li><p><code>parsimony</code>: A multiplicative factor for how much complexity is   punished.</p></li><li><p><code>dimensional_constraint_penalty</code>: An additive factor if the dimensional   constraint is violated.</p></li><li><p><code>dimensionless_constants_only</code>: Whether to only allow dimensionless   constants.</p></li><li><p><code>use_frequency</code>: Whether to use a parsimony that adapts to the   relative proportion of equations at each complexity; this will   ensure that there are a balanced number of equations considered   for every complexity.</p></li><li><p><code>use_frequency_in_tournament</code>: Whether to use the adaptive parsimony described   above inside the score, rather than just at the mutation accept/reject stage.</p></li><li><p><code>adaptive_parsimony_scaling</code>: How much to scale the adaptive parsimony term   in the loss. Increase this if the search is spending too much time   optimizing the most complex equations.</p></li><li><p><code>turbo</code>: Whether to use <code>LoopVectorization.@turbo</code> to evaluate expressions.   This can be significantly faster, but is only compatible with certain   operators. <em>Experimental!</em></p></li><li><p><code>bumper</code>: Whether to use Bumper.jl for faster evaluation. <em>Experimental!</em></p></li><li><p><code>migration</code>: Whether to migrate equations between processes.</p></li><li><p><code>hof_migration</code>: Whether to migrate equations from the hall of fame   to processes.</p></li><li><p><code>fraction_replaced</code>: What fraction of each population to replace with   migrated equations at the end of each cycle.</p></li><li><p><code>fraction_replaced_hof</code>: What fraction to replace with hall of fame   equations at the end of each cycle.</p></li><li><p><code>should_simplify</code>: Whether to simplify equations. If you   pass a custom objective, this will be set to <code>false</code>.</p></li><li><p><code>should_optimize_constants</code>: Whether to use an optimization algorithm   to periodically optimize constants in equations.</p></li><li><p><code>optimizer_algorithm</code>: Select algorithm to use for optimizing constants. Default   is <code>Optim.BFGS(linesearch=LineSearches.BackTracking())</code>.</p></li><li><p><code>optimizer_nrestarts</code>: How many different random starting positions to consider   for optimization of constants.</p></li><li><p><code>optimizer_probability</code>: Probability of performing optimization of constants at   the end of a given iteration.</p></li><li><p><code>optimizer_iterations</code>: How many optimization iterations to perform. This gets   passed to <code>Optim.Options</code> as <code>iterations</code>. The default is 8.</p></li><li><p><code>optimizer_f_calls_limit</code>: How many function calls to allow during optimization.   This gets passed to <code>Optim.Options</code> as <code>f_calls_limit</code>. The default is   <code>10_000</code>.</p></li><li><p><code>optimizer_options</code>: General options for the constant optimization. For details   we refer to the documentation on <code>Optim.Options</code> from the <code>Optim.jl</code> package.   Options can be provided here as <code>NamedTuple</code>, e.g. <code>(iterations=16,)</code>, as a   <code>Dict</code>, e.g. Dict(:x_tol =&gt; 1.0e-32,), or as an <code>Optim.Options</code> instance.</p></li><li><p><code>autodiff_backend</code>: The backend to use for differentiation, which should be   an instance of <code>AbstractADType</code> (see <code>ADTypes.jl</code>).   Default is <code>nothing</code>, which means <code>Optim.jl</code> will estimate gradients (likely   with finite differences). You can also pass a symbolic version of the backend   type, such as <code>:Zygote</code> for Zygote, <code>:Enzyme</code>, etc. Most backends will not   work, and many will never work due to incompatibilities, though support for some   is gradually being added.</p></li><li><p><code>perturbation_factor</code>: When mutating a constant, either   multiply or divide by (1+perturbation_factor)^(rand()+1).</p></li><li><p><code>probability_negate_constant</code>: Probability of negating a constant in the equation   when mutating it.</p></li><li><p><code>mutation_weights</code>: Relative probabilities of the mutations. The struct   <code>MutationWeights</code> (or any <code>AbstractMutationWeights</code>) should be passed to these options.   See its documentation on <code>MutationWeights</code> for the different weights.</p></li><li><p><code>crossover_probability</code>: Probability of performing crossover.</p></li><li><p><code>annealing</code>: Whether to use simulated annealing.</p></li><li><p><code>warmup_maxsize_by</code>: Whether to slowly increase the max size from 5 up to   <code>maxsize</code>. If nonzero, specifies the fraction through the search   at which the maxsize should be reached.</p></li><li><p><code>verbosity</code>: Whether to print debugging statements or   not.</p></li><li><p><code>print_precision</code>: How many digits to print when printing   equations. By default, this is 5.</p></li><li><p><code>output_directory</code>: The base directory to save output files to. Files   will be saved in a subdirectory according to the run ID. By default,   this is <code>./outputs</code>.</p></li><li><p><code>save_to_file</code>: Whether to save equations to a file during the search.</p></li><li><p><code>bin_constraints</code>: See <code>constraints</code>. This is the same, but specified for binary   operators only (for example, if you have an operator that is both a binary   and unary operator).</p></li><li><p><code>una_constraints</code>: Likewise, for unary operators.</p></li><li><p><code>seed</code>: What random seed to use. <code>nothing</code> uses no seed.</p></li><li><p><code>progress</code>: Whether to use a progress bar output (<code>verbosity</code> will   have no effect).</p></li><li><p><code>early_stop_condition</code>: Float - whether to stop early if the mean loss gets below this value.   Function - a function taking (loss, complexity) as arguments and returning true or false.</p></li><li><p><code>timeout_in_seconds</code>: Float64 - the time in seconds after which to exit (as an alternative to the number of iterations).</p></li><li><p><code>max_evals</code>: Int (or Nothing) - the maximum number of evaluations of expressions to perform.</p></li><li><p><code>input_stream</code>: the stream to read user input from. By default, this is <code>stdin</code>. If you encounter issues   with reading from <code>stdin</code>, like a hang, you can simply pass <code>devnull</code> to this argument.</p></li><li><p><code>skip_mutation_failures</code>: Whether to simply skip over mutations that fail or are rejected, rather than to replace the mutated   expression with the original expression and proceed normally.</p></li><li><p><code>nested_constraints</code>: Specifies how many times a combination of operators can be nested. For example,   <code>[sin =&gt; [cos =&gt; 0], cos =&gt; [cos =&gt; 2]]</code> specifies that <code>cos</code> may never appear within a <code>sin</code>,   but <code>sin</code> can be nested with itself an unlimited number of times. The second term specifies that <code>cos</code>   can be nested up to 2 times within a <code>cos</code>, so that <code>cos(cos(cos(x)))</code> is allowed (as well as any combination   of <code>+</code> or <code>-</code> within it), but <code>cos(cos(cos(cos(x))))</code> is not allowed. When an operator is not specified,   it is assumed that it can be nested an unlimited number of times. This requires that there is no operator   which is used both in the unary operators and the binary operators (e.g., <code>-</code> could be both subtract, and negation).   For binary operators, both arguments are treated the same way, and the max of each argument is constrained.</p></li><li><p><code>deterministic</code>: Use a global counter for the birth time, rather than calls to <code>time()</code>. This gives   perfect resolution, and is therefore deterministic. However, it is not thread safe, and must be used   in serial mode.</p></li><li><p><code>define_helper_functions</code>: Whether to define helper functions   for constructing and evaluating trees.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/Options.jl#L451-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.CoreModule.MutationWeightsModule.MutationWeights" href="#SymbolicRegression.CoreModule.MutationWeightsModule.MutationWeights"><code>SymbolicRegression.CoreModule.MutationWeightsModule.MutationWeights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MutationWeights(;kws...) &lt;: AbstractMutationWeights</code></pre><p>This defines how often different mutations occur. These weightings will be normalized to sum to 1.0 after initialization.</p><p><strong>Arguments</strong></p><ul><li><code>mutate_constant::Float64</code>: How often to mutate a constant.</li><li><code>mutate_operator::Float64</code>: How often to mutate an operator.</li><li><code>swap_operands::Float64</code>: How often to swap the operands of a binary operator.</li><li><code>rotate_tree::Float64</code>: How often to perform a tree rotation at a random node.</li><li><code>add_node::Float64</code>: How often to append a node to the tree.</li><li><code>insert_node::Float64</code>: How often to insert a node into the tree.</li><li><code>delete_node::Float64</code>: How often to delete a node from the tree.</li><li><code>simplify::Float64</code>: How often to simplify the tree.</li><li><code>randomize::Float64</code>: How often to create a random tree.</li><li><code>do_nothing::Float64</code>: How often to do nothing.</li><li><code>optimize::Float64</code>: How often to optimize the constants in the tree, as a mutation.   Note that this is different from <code>optimizer_probability</code>, which is   performed at the end of an iteration for all individuals.</li><li><code>form_connection::Float64</code>: <strong>Only used for <code>GraphNode</code>, not regular <code>Node</code></strong>.   Otherwise, this will automatically be set to 0.0. How often to form a   connection between two nodes.</li><li><code>break_connection::Float64</code>: <strong>Only used for <code>GraphNode</code>, not regular <code>Node</code></strong>.   Otherwise, this will automatically be set to 0.0. How often to break a   connection between two nodes.</li></ul><p><strong>See Also</strong></p><ul><li><a href="@ref SymbolicRegression.CoreModule.MutationWeightsModule.AbstractMutationWeights"><code>AbstractMutationWeights</code></a>: Use to define custom mutation weight types.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/MutationWeights.jl#L70-L101">source</a></section></article><h2 id="Printing"><a class="docs-heading-anchor" href="#Printing">Printing</a><a id="Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Printing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.StringsModule.string_tree" href="#DynamicExpressions.StringsModule.string_tree"><code>DynamicExpressions.StringsModule.string_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">string_tree(
    tree::AbstractExpressionNode{T},
    operators::Union{AbstractOperatorEnum,Nothing}=nothing;
    f_variable::F1=string_variable,
    f_constant::F2=string_constant,
    variable_names::Union{Array{String,1},Nothing}=nothing,
    # Deprecated
    varMap=nothing,
)::String where {T,F1&lt;:Function,F2&lt;:Function}</code></pre><p>Convert an equation to a string.</p><p><strong>Arguments</strong></p><ul><li><code>tree</code>: the tree to convert to a string</li><li><code>operators</code>: the operators used to define the tree</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>f_variable</code>: (optional) function to convert a variable to a string, with arguments <code>(feature::UInt8, variable_names)</code>.</li><li><code>f_constant</code>: (optional) function to convert a constant to a string, with arguments <code>(val,)</code></li><li><code>variable_names::Union{Array{String, 1}, Nothing}=nothing</code>: (optional) what variables to print for each feature.</li></ul></div></section><section><div><pre><code class="nohighlight hljs">string_tree(
    ex::AbstractExpression,
    operators::Union{AbstractOperatorEnum,Nothing}=nothing;
    variable_names=nothing,
    kws...
)</code></pre><p>Convert an expression to a string representation.</p><p>This method unpacks the operators and variable names from the expression and calls <a href="@ref StringsModule.string_tree"><code>string_tree</code></a> for <code>AbstractExpressionNode</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ex</code>: The expression to convert to a string.</li><li><code>operators</code>: (Optional) Operators to use. If <code>nothing</code>, operators are obtained from the expression.</li><li><code>variable_names</code>: (Optional) Variable names to use in the string representation. If <code>nothing</code>, variable names are obtained from the expression.</li><li><code>kws...</code>: Additional keyword arguments.</li></ul><p><strong>Returns</strong></p><ul><li>A string representation of the expression.</li></ul></div></section><section><div><pre><code class="nohighlight hljs">string_tree(tree::AbstractExpressionNode, options::AbstractOptions; kws...)</code></pre><p>Convert an equation to a string.</p><p><strong>Arguments</strong></p><ul><li><code>tree::AbstractExpressionNode</code>: The equation to convert to a string.</li><li><code>options::AbstractOptions</code>: The options holding the definition of operators.</li><li><code>variable_names::Union{Array{String, 1}, Nothing}=nothing</code>: what variables   to print for each feature.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/InterfaceDynamicExpressions.jl#L175-L186">source</a></section></article><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateModule.eval_tree_array" href="#DynamicExpressions.EvaluateModule.eval_tree_array"><code>DynamicExpressions.EvaluateModule.eval_tree_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_tree_array(
    tree::AbstractExpressionNode{T},
    cX::AbstractMatrix{T},
    operators::OperatorEnum;
    eval_options::Union{EvalOptions,Nothing}=nothing,
) where {T}</code></pre><p>Evaluate a binary tree (equation) over a given input data matrix. The operators contain all of the operators used. This function fuses doublets and triplets of operations for lower memory usage.</p><p><strong>Arguments</strong></p><ul><li><code>tree::AbstractExpressionNode</code>: The root node of the tree to evaluate.</li><li><code>cX::AbstractMatrix{T}</code>: The input data to evaluate the tree on, with shape <code>[num_features, num_rows]</code>.</li><li><code>operators::OperatorEnum</code>: The operators used in the tree.</li><li><code>eval_options::Union{EvalOptions,Nothing}</code>: See <a href="#DynamicExpressions.EvaluateModule.EvalOptions"><code>EvalOptions</code></a> for documentation   on the different evaluation modes.</li></ul><p><strong>Returns</strong></p><ul><li><code>(output, complete)::Tuple{AbstractVector{T}, Bool}</code>: the result,   which is a 1D array, as well as if the evaluation completed   successfully (true/false). A <code>false</code> complete means an infinity   or nan was encountered, and a large loss should be assigned   to the equation.</li></ul><p><strong>Notes</strong></p><p>This function can be represented by the following pseudocode:</p><pre><code class="nohighlight hljs">def eval(current_node)
    if current_node is leaf
        return current_node.value
    elif current_node is degree 1
        return current_node.operator(eval(current_node.left_child))
    else
        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))</code></pre><p>The bulk of the code is for optimizations and pre-emptive NaN/Inf checks, which speed up evaluation significantly.</p></div></section><section><div><pre><code class="nohighlight hljs">eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)</code></pre><p>Evaluate a generic binary tree (equation) over a given input data, whatever that input data may be. The <code>operators</code> enum contains all of the operators used. Unlike <code>eval_tree_array</code> with the normal <code>OperatorEnum</code>, the array <code>cX</code> is sliced only along the first dimension. i.e., if <code>cX</code> is a vector, then the output of a feature node will be a scalar. If <code>cX</code> is a 3D tensor, then the output of a feature node will be a 2D tensor. Note also that <code>tree.feature</code> will index along the first axis of <code>cX</code>.</p><p>However, there is no requirement about input and output types in general. You may set up your tree such that some operator nodes work on tensors, while other operator nodes work on scalars. <code>eval_tree_array</code> will simply return <code>nothing</code> if a given operator is not defined for the given input type.</p><p>This function can be represented by the following pseudocode:</p><pre><code class="nohighlight hljs">function eval(current_node)
    if current_node is leaf
        return current_node.value
    elif current_node is degree 1
        return current_node.operator(eval(current_node.left_child))
    else
        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))</code></pre><p><strong>Arguments</strong></p><ul><li><code>tree::AbstractExpressionNode</code>: The root node of the tree to evaluate.</li><li><code>cX::AbstractArray</code>: The input data to evaluate the tree on.</li><li><code>operators::GenericOperatorEnum</code>: The operators used in the tree.</li><li><code>throw_errors::Bool=true</code>: Whether to throw errors   if they occur during evaluation. Otherwise,   MethodErrors will be caught before they happen and    evaluation will return <code>nothing</code>,   rather than throwing an error. This is useful in cases   where you are unsure if a particular tree is valid or not,   and would prefer to work with <code>nothing</code> as an output.</li></ul><p><strong>Returns</strong></p><ul><li><code>(output, complete)::Tuple{Any, Bool}</code>: the result,   as well as if the evaluation completed successfully (true/false).   If evaluation failed, <code>nothing</code> will be returned for the first argument.   A <code>false</code> complete means an operator was called on input types   that it was not defined for.</li></ul></div></section><section><div><pre><code class="nohighlight hljs">eval_tree_array(
    ex::AbstractExpression,
    cX::AbstractMatrix,
    operators::Union{AbstractOperatorEnum,Nothing}=nothing;
    kws...
)</code></pre><p>Evaluate an expression over a given input data matrix.</p><p>This method unpacks the operators from the expression and calls <a href="@ref EvaluateModule.eval_tree_array"><code>eval_tree_array</code></a> for <code>AbstractExpressionNode</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ex</code>: The expression to evaluate.</li><li><code>cX</code>: The input data matrix.</li><li><code>operators</code>: (Optional) Operators to use. If <code>nothing</code>, operators are obtained from the expression.</li><li><code>kws...</code>: Additional keyword arguments.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(output, complete)</code> indicating the result and success of the evaluation.</li></ul></div></section><section><div><pre><code class="nohighlight hljs">eval_tree_array(tree::Union{AbstractExpression,AbstractExpressionNode}, X::AbstractArray, options::AbstractOptions; kws...)</code></pre><p>Evaluate a binary tree (equation) over a given input data matrix. The operators contain all of the operators used. This function fuses doublets and triplets of operations for lower memory usage.</p><p>This function can be represented by the following pseudocode:</p><pre><code class="nohighlight hljs">function eval(current_node)
    if current_node is leaf
        return current_node.value
    elif current_node is degree 1
        return current_node.operator(eval(current_node.left_child))
    else
        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))</code></pre><p>The bulk of the code is for optimizations and pre-emptive NaN/Inf checks, which speed up evaluation significantly.</p><p><strong>Arguments</strong></p><ul><li><code>tree::Union{AbstractExpression,AbstractExpressionNode}</code>: The root node of the tree to evaluate.</li><li><code>X::AbstractArray</code>: The input data to evaluate the tree on.</li><li><code>options::AbstractOptions</code>: Options used to define the operators used in the tree.</li></ul><p><strong>Returns</strong></p><ul><li><code>(output, complete)::Tuple{AbstractVector, Bool}</code>: the result,   which is a 1D array, as well as if the evaluation completed   successfully (true/false). A <code>false</code> complete means an infinity   or nan was encountered, and a large loss should be assigned   to the equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/InterfaceDynamicExpressions.jl#L20-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateModule.EvalOptions" href="#DynamicExpressions.EvaluateModule.EvalOptions"><code>DynamicExpressions.EvaluateModule.EvalOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EvalOptions</code></pre><p>This holds options for expression evaluation, such as evaluation backend.</p><p><strong>Fields</strong></p><ul><li><code>turbo::Val{T}=Val(false)</code>: If <code>Val{true}</code>, use LoopVectorization.jl for faster   evaluation.</li><li><code>bumper::Val{B}=Val(false)</code>: If <code>Val{true}</code>, use Bumper.jl for faster evaluation.</li><li><code>early_exit::Val{E}=Val(true)</code>: If <code>Val{true}</code>, any element of any step becoming   <code>NaN</code> or <code>Inf</code> will terminate the computation. For <code>eval_tree_array</code>, this will   result in the second return value, the completion flag, being <code>false</code>. For    calling an expression using <code>tree(X)</code>, this will result in <code>NaN</code>s filling   the entire buffer. This early exit is performed to avoid wasting compute cycles.   Setting <code>Val{false}</code> will continue the computation as usual and thus result in   <code>NaN</code>s only in the elements that actually have <code>NaN</code>s.</li><li><code>buffer::Union{ArrayBuffer,Nothing}</code>: If not <code>nothing</code>, use this buffer for evaluation.   This should be an instance of <code>ArrayBuffer</code> which has an <code>array</code> field and an   <code>index</code> field used to iterate which buffer slot to use.</li></ul></div></section></article><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><p><code>SymbolicRegression.jl</code> can automatically and efficiently compute derivatives of expressions with respect to variables or constants. This is done using either <code>eval_diff_tree_array</code>, to compute derivative with respect to a single variable, or with <code>eval_grad_tree_array</code>, to compute the gradient with respect all variables (or, all constants). Both use forward-mode automatic, but use <code>Zygote.jl</code> to compute derivatives of each operator, so this is very efficient.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateDerivativeModule.eval_diff_tree_array" href="#DynamicExpressions.EvaluateDerivativeModule.eval_diff_tree_array"><code>DynamicExpressions.EvaluateDerivativeModule.eval_diff_tree_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_diff_tree_array(
    tree::AbstractExpressionNode{T},
    cX::AbstractMatrix{T},
    operators::OperatorEnum,
    direction::Integer;
    turbo::Union{Bool,Val}=Val(false)
) where {T&lt;:Number}</code></pre><p>Compute the forward derivative of an expression, using a similar structure and optimization to eval<em>tree</em>array. <code>direction</code> is the index of a particular variable in the expression. e.g., <code>direction=1</code> would indicate derivative with respect to <code>x1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tree::AbstractExpressionNode</code>: The expression tree to evaluate.</li><li><code>cX::AbstractMatrix{T}</code>: The data matrix, with shape <code>[num_features, num_rows]</code>.</li><li><code>operators::OperatorEnum</code>: The operators used to create the <code>tree</code>.</li><li><code>direction::Integer</code>: The index of the variable to take the derivative with respect to.</li><li><code>turbo::Union{Bool,Val}</code>: Use LoopVectorization.jl for faster evaluation. Currently this does not have   any effect.</li></ul><p><strong>Returns</strong></p><ul><li><code>(evaluation, derivative, complete)::Tuple{AbstractVector{T}, AbstractVector{T}, Bool}</code>: the normal evaluation,   the derivative, and whether the evaluation completed as normal (or encountered a nan or inf).</li></ul></div></section><section><div><pre><code class="nohighlight hljs">eval_diff_tree_array(tree::Union{AbstractExpression,AbstractExpressionNode}, X::AbstractArray, options::AbstractOptions, direction::Int)</code></pre><p>Compute the forward derivative of an expression, using a similar structure and optimization to eval<em>tree</em>array. <code>direction</code> is the index of a particular variable in the expression. e.g., <code>direction=1</code> would indicate derivative with respect to <code>x1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tree::Union{AbstractExpression,AbstractExpressionNode}</code>: The expression tree to evaluate.</li><li><code>X::AbstractArray</code>: The data matrix, with each column being a data point.</li><li><code>options::AbstractOptions</code>: The options containing the operators used to create the <code>tree</code>.</li><li><code>direction::Int</code>: The index of the variable to take the derivative with respect to.</li></ul><p><strong>Returns</strong></p><ul><li><code>(evaluation, derivative, complete)::Tuple{AbstractVector, AbstractVector, Bool}</code>: the normal evaluation,   the derivative, and whether the evaluation completed as normal (or encountered a nan or inf).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/InterfaceDynamicExpressions.jl#L86-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateDerivativeModule.eval_grad_tree_array" href="#DynamicExpressions.EvaluateDerivativeModule.eval_grad_tree_array"><code>DynamicExpressions.EvaluateDerivativeModule.eval_grad_tree_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_grad_tree_array(tree::AbstractExpressionNode{T}, cX::AbstractMatrix{T}, operators::OperatorEnum; variable::Union{Bool,Val}=Val(false), turbo::Union{Bool,Val}=Val(false))</code></pre><p>Compute the forward-mode derivative of an expression, using a similar structure and optimization to eval<em>tree</em>array. <code>variable</code> specifies whether we should take derivatives with respect to features (i.e., cX), or with respect to every constant in the expression.</p><p><strong>Arguments</strong></p><ul><li><code>tree::AbstractExpressionNode{T}</code>: The expression tree to evaluate.</li><li><code>cX::AbstractMatrix{T}</code>: The data matrix, with each column being a data point.</li><li><code>operators::OperatorEnum</code>: The operators used to create the <code>tree</code>.</li><li><code>variable::Union{Bool,Val}</code>: Whether to take derivatives with respect to features (i.e., <code>cX</code> - with <code>variable=true</code>),   or with respect to every constant in the expression (<code>variable=false</code>).</li><li><code>turbo::Union{Bool,Val}</code>: Use LoopVectorization.jl for faster evaluation. Currently this does not have   any effect.</li></ul><p><strong>Returns</strong></p><ul><li><code>(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}</code>: the normal evaluation,   the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).</li></ul></div></section><section><div><pre><code class="nohighlight hljs">eval_grad_tree_array(
    ex::AbstractExpression,
    cX::AbstractMatrix,
    operators::Union{AbstractOperatorEnum,Nothing}=nothing;
    kws...
)</code></pre><p>Compute the forward-mode derivative of an expression.</p><p>This method unpacks the operators from the expression and calls <a href="@ref EvaluateDerivativeModule.eval_grad_tree_array"><code>eval_grad_tree_array</code></a> for <code>AbstractExpressionNode</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ex</code>: The expression to evaluate.</li><li><code>cX</code>: The data matrix.</li><li><code>operators</code>: (Optional) Operators to use. If <code>nothing</code>, operators are obtained from the expression.</li><li><code>kws...</code>: Additional keyword arguments.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(output, gradient, complete)</code> indicating the result, gradient, and success of the evaluation.</li></ul></div></section><section><div><pre><code class="nohighlight hljs">eval_grad_tree_array(tree::Union{AbstractExpression,AbstractExpressionNode}, X::AbstractArray, options::AbstractOptions; variable::Bool=false)</code></pre><p>Compute the forward-mode derivative of an expression, using a similar structure and optimization to eval<em>tree</em>array. <code>variable</code> specifies whether we should take derivatives with respect to features (i.e., <code>X</code>), or with respect to every constant in the expression.</p><p><strong>Arguments</strong></p><ul><li><code>tree::Union{AbstractExpression,AbstractExpressionNode}</code>: The expression tree to evaluate.</li><li><code>X::AbstractArray</code>: The data matrix, with each column being a data point.</li><li><code>options::AbstractOptions</code>: The options containing the operators used to create the <code>tree</code>.</li><li><code>variable::Bool</code>: Whether to take derivatives with respect to features (i.e., <code>X</code> - with <code>variable=true</code>),   or with respect to every constant in the expression (<code>variable=false</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>(evaluation, gradient, complete)::Tuple{AbstractVector, AbstractArray, Bool}</code>: the normal evaluation,   the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/InterfaceDynamicExpressions.jl#L120-L140">source</a></section></article><h2 id="SymbolicUtils.jl-interface"><a class="docs-heading-anchor" href="#SymbolicUtils.jl-interface">SymbolicUtils.jl interface</a><a id="SymbolicUtils.jl-interface-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicUtils.jl-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.ExtensionInterfaceModule.node_to_symbolic" href="#DynamicExpressions.ExtensionInterfaceModule.node_to_symbolic"><code>DynamicExpressions.ExtensionInterfaceModule.node_to_symbolic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">node_to_symbolic(tree::AbstractExpressionNode, operators::AbstractOperatorEnum;
            variable_names::Union{AbstractVector{&lt;:AbstractString}, Nothing}=nothing,
            index_functions::Bool=false)</code></pre><p>The interface to SymbolicUtils.jl. Passing a tree to this function will generate a symbolic equation in SymbolicUtils.jl format.</p><p><strong>Arguments</strong></p><ul><li><code>tree::AbstractExpressionNode</code>: The equation to convert.</li><li><code>operators::AbstractOperatorEnum</code>: OperatorEnum, which contains the operators used in the equation.</li><li><code>variable_names::Union{AbstractVector{&lt;:AbstractString}, Nothing}=nothing</code>: What variable names to use for   each feature. Default is [x1, x2, x3, ...].</li><li><code>index_functions::Bool=false</code>: Whether to generate special names for the   operators, which then allows one to convert back to a <code>AbstractExpressionNode</code> format   using <code>symbolic_to_node</code>.   (CURRENTLY UNAVAILABLE - See https://github.com/MilesCranmer/SymbolicRegression.jl/pull/84).</li></ul></div></section><section><div><pre><code class="nohighlight hljs">node_to_symbolic(tree::AbstractExpressionNode, options::Options; kws...)</code></pre><p>Convert an expression to SymbolicUtils.jl form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/ext/SymbolicRegressionSymbolicUtilsExt.jl#L10-L14">source</a></section></article><p>Note that use of this function requires <code>SymbolicUtils.jl</code> to be installed and loaded.</p><h2 id="Pareto-frontier"><a class="docs-heading-anchor" href="#Pareto-frontier">Pareto frontier</a><a id="Pareto-frontier-1"></a><a class="docs-heading-anchor-permalink" href="#Pareto-frontier" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.HallOfFameModule.calculate_pareto_frontier" href="#SymbolicRegression.HallOfFameModule.calculate_pareto_frontier"><code>SymbolicRegression.HallOfFameModule.calculate_pareto_frontier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_pareto_frontier(hallOfFame::HallOfFame{T,L,P}) where {T&lt;:DATA_TYPE,L&lt;:LOSS_TYPE}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/HallOfFame.jl#L89-L91">source</a></section></article><h2 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.LoggingModule.SRLogger" href="#SymbolicRegression.LoggingModule.SRLogger"><code>SymbolicRegression.LoggingModule.SRLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SRLogger(logger::AbstractLogger; log_interval::Int=100)</code></pre><p>A logger for symbolic regression that wraps another logger.</p><p><strong>Arguments</strong></p><ul><li><code>logger</code>: The base logger to wrap</li><li><code>log_interval</code>: Number of steps between logging events. Default is 100 (log every 100 steps).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/ddb7efb895eedc0568b9179254bb572d9a47bbbb/src/Logging.jl#L30-L38">source</a></section></article><p>The <code>SRLogger</code> allows you to track the progress of symbolic regression searches. It can wrap any <code>AbstractLogger</code> that implements the Julia logging interface, such as from TensorBoardLogger.jl or Wandb.jl.</p><pre><code class="language-julia hljs">using TensorBoardLogger

logger = SRLogger(TBLogger(&quot;logs/run&quot;), log_interval=2)

model = SRRegressor(;
    logger=logger,
    kws...
)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/parameterized_function/">« Parameterized Expressions</a><a class="docs-footer-nextpage" href="../losses/">Losses »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 2 February 2025 14:41">Sunday 2 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
